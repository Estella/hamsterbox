#ifndef lint
static const char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif

#include <stdlib.h>
#include <string.h>

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYPATCH 20070509

#define YYEMPTY (-1)
#define yyclearin    (yychar = YYEMPTY)
#define yyerrok      (yyerrflag = 0)
#define YYRECOVERING (yyerrflag != 0)

extern int yyparse(void);

static int yygrowstack(void);
#define YYPREFIX "yy"
#line 26 "ircd_parser.y"

#define YY_NO_UNPUT
#include <sys/types.h>

#include "stdinc.h"
#include "ircd.h"
#include "tools.h"
#include "list.h"
#include "s_conf.h"
#include "event.h"
#include "s_log.h"
#include "client.h"	/* for UMODE_ALL only */
#include "pcre.h"
#include "irc_string.h"
#include "irc_getaddrinfo.h"
#include "sprintf_irc.h"
#include "memory.h"
#include "modules.h"
#include "s_serv.h" /* for CAP_LL / IsCapable */
#include "s_misc.h" /* for certfp funcs */
#include "hostmask.h"
#include "send.h"
#include "listener.h"
#include "resv.h"
#include "numeric.h"
#include "s_user.h"

#ifdef HAVE_LIBCRYPTO
#include <openssl/rsa.h>
#include <openssl/bio.h>
#include <openssl/pem.h>
#endif

static char *class_name = NULL;
static struct ConfItem *yy_conf = NULL;
static struct AccessItem *yy_aconf = NULL;
static struct MatchItem *yy_match_item = NULL;
static struct ClassItem *yy_class = NULL;
static struct DnsblItem *yy_dconf = NULL;
static char *yy_class_name = NULL;

static dlink_list col_conf_list  = { NULL, NULL, 0 };
static dlink_list hub_conf_list  = { NULL, NULL, 0 };
static dlink_list leaf_conf_list = { NULL, NULL, 0 };
static unsigned int listener_flags = 0;
static unsigned int regex_ban = 0;
static char userbuf[IRCD_BUFSIZE];
static char hostbuf[IRCD_BUFSIZE];
static char reasonbuf[REASONLEN + 1];
static char gecos_name[REALLEN * 4];

extern dlink_list gdeny_items; /* XXX */

static char *resv_reason = NULL;
static char *listener_address = NULL;
static int not_atom = 0;

struct CollectItem {
  dlink_node node;
  char *name;
  char *user;
  char *host;
  char *passwd;
  int  port;
  int  flags;
#ifdef HAVE_LIBCRYPTO
  char *rsa_public_key_file;
  RSA *rsa_public_key;
#endif
};

static void
free_collect_item(struct CollectItem *item)
{
  MyFree(item->name);
  MyFree(item->user);
  MyFree(item->host);
  MyFree(item->passwd);
#ifdef HAVE_LIBCRYPTO
  MyFree(item->rsa_public_key_file);
#endif
  MyFree(item);
}

static void
unhook_hub_leaf_confs(void)
{
  dlink_node *ptr;
  dlink_node *next_ptr;
  struct CollectItem *yy_hconf;
  struct CollectItem *yy_lconf;

  DLINK_FOREACH_SAFE(ptr, next_ptr, hub_conf_list.head)
  {
    yy_hconf = ptr->data;
    dlinkDelete(&yy_hconf->node, &hub_conf_list);
    free_collect_item(yy_hconf);
  }

  DLINK_FOREACH_SAFE(ptr, next_ptr, leaf_conf_list.head)
  {
    yy_lconf = ptr->data;
    dlinkDelete(&yy_lconf->node, &leaf_conf_list);
    free_collect_item(yy_lconf);
  }
}

#line 135 "ircd_parser.y"
typedef union {
  int number;
  char *string;
} YYSTYPE;
#line 136 "y.tab.c"
#define ACCEPT_PASSWORD 257
#define ACTION 258
#define ADMIN 259
#define AFTYPE 260
#define T_ALLOW 261
#define ANTI_NICK_FLOOD 262
#define ANTI_SPAM_EXIT_MESSAGE_TIME 263
#define ANTI_SPAM_CONNECT_NUMERIC 264
#define AUTOCONN 265
#define T_BLOCK 266
#define BURST_AWAY 267
#define BURST_TOPICWHO 268
#define BYTES 269
#define KBYTES 270
#define MBYTES 271
#define GBYTES 272
#define TBYTES 273
#define CALLER_ID_WAIT 274
#define CAN_FLOOD 275
#define CAN_IDLE 276
#define CHANNEL 277
#define CIDR_BITLEN_IPV4 278
#define CIDR_BITLEN_IPV6 279
#define CIPHER_PREFERENCE 280
#define CLASS 281
#define CLIENTCERT_HASH 282
#define CLOAK_KEY1 283
#define CLOAK_KEY2 284
#define CLOAK_KEY3 285
#define CLOAK_WHOIS_ACTUALLY 286
#define COMPRESSED 287
#define COMPRESSION_LEVEL 288
#define CONNECT 289
#define CONNECTFREQ 290
#define CRYPTLINK 291
#define CYCLE_ON_HOSTCHANGE 292
#define DEFAULT_CIPHER_PREFERENCE 293
#define DEFAULT_FLOODCOUNT 294
#define DEFAULT_SPLIT_SERVER_COUNT 295
#define DEFAULT_SPLIT_USER_COUNT 296
#define DENY 297
#define DESCRIPTION 298
#define DIE 299
#define DISABLE_AUTH 300
#define DISABLE_FAKE_CHANNELS 301
#define DISABLE_HIDDEN 302
#define DISABLE_LOCAL_CHANNELS 303
#define DISABLE_REMOTE_COMMANDS 304
#define DNSBL 305
#define DOT_IN_IP6_ADDR 306
#define DOTS_IN_IDENT 307
#define DURATION 308
#define EGDPOOL_PATH 309
#define EMAIL 310
#define ENABLE 311
#define ENCRYPTED 312
#define EXCEED_LIMIT 313
#define EXEMPT 314
#define FAILED_OPER_NOTICE 315
#define FAKENAME 316
#define IRCD_FLAGS 317
#define FLATTEN_LINKS 318
#define FFAILED_OPERLOG 319
#define FKILLLOG 320
#define FKLINELOG 321
#define FGLINELOG 322
#define FIOERRLOG 323
#define FOPERLOG 324
#define FOPERSPYLOG 325
#define FUSERLOG 326
#define GECOS 327
#define GENERAL 328
#define GLINE 329
#define GLINES 330
#define GLINE_EXEMPT 331
#define GLINE_LOG 332
#define GLINE_TIME 333
#define GLINE_MIN_CIDR 334
#define GLINE_MIN_CIDR6 335
#define GLOBAL_KILL 336
#define IRCD_AUTH 337
#define NEED_IDENT 338
#define HAVENT_READ_CONF 339
#define HIDDEN 340
#define HIDDEN_ADMIN 341
#define HIDDEN_NAME 342
#define HIDDEN_OPER 343
#define HIDE_SERVER_IPS 344
#define HIDE_SERVERS 345
#define HIDE_SPOOF_IPS 346
#define HOST 347
#define HUB 348
#define HUB_MASK 349
#define IDLETIME 350
#define IGNORE_BOGUS_TS 351
#define INVISIBLE_ON_CONNECT 352
#define IP 353
#define KILL 354
#define KILL_CHASE_TIME_LIMIT 355
#define KLINE 356
#define KLINE_EXEMPT 357
#define KLINE_REASON 358
#define KLINE_WITH_REASON 359
#define KNOCK_DELAY 360
#define KNOCK_DELAY_CHANNEL 361
#define LAZYLINK 362
#define LEAF_MASK 363
#define LINKS_DELAY 364
#define LISTEN 365
#define T_LOG 366
#define LOGGING 367
#define LOG_LEVEL 368
#define MAX_ACCEPT 369
#define MAX_BANS 370
#define MAX_CHANS_PER_USER 371
#define MAX_GLOBAL 372
#define MAX_IDENT 373
#define MAX_LOCAL 374
#define MAX_NICK_CHANGES 375
#define MAX_NICK_TIME 376
#define MAX_NUMBER 377
#define MAX_TARGETS 378
#define MESSAGE_LOCALE 379
#define MIN_NONWILDCARD 380
#define MIN_NONWILDCARD_SIMPLE 381
#define MODULE 382
#define MODULES 383
#define NAME 384
#define NEED_PASSWORD 385
#define IS_WEBIRC 386
#define NETWORK_DESC 387
#define NETWORK_NAME 388
#define NICK 389
#define NICK_CHANGES 390
#define NO_CREATE_ON_SPLIT 391
#define NO_JOIN_ON_SPLIT 392
#define NO_OPER_FLOOD 393
#define NO_TILDE 394
#define NOT 395
#define NUMBER 396
#define NUMBER_PER_IDENT 397
#define NUMBER_PER_CIDR 398
#define NUMBER_PER_IP 399
#define NUMBER_PER_IP_GLOBAL 400
#define OPERATOR 401
#define OPERS_BYPASS_CALLERID 402
#define OPER_LOG 403
#define OPER_ONLY_UMODES 404
#define OPER_PASS_RESV 405
#define OPER_SPY_T 406
#define OPER_FARCONNECT 407
#define OPER_UMODES 408
#define JOIN_FLOOD_COUNT 409
#define JOIN_FLOOD_TIME 410
#define PACE_WAIT 411
#define PACE_WAIT_SIMPLE 412
#define PASSWORD 413
#define PATH 414
#define PING_COOKIE 415
#define PING_TIME 416
#define PING_WARNING 417
#define PORT 418
#define QSTRING 419
#define QUIET_ON_BAN 420
#define REASON 421
#define REDIRPORT 422
#define REDIRSERV 423
#define REGEX_T 424
#define REHASH 425
#define TREJECT_HOLD_TIME 426
#define REMOTE 427
#define REMOTEBAN 428
#define RESTRICT_CHANNELS 429
#define RESTRICTED 430
#define RSA_PRIVATE_KEY_FILE 431
#define RSA_PUBLIC_KEY_FILE 432
#define SSL_CERTIFICATE_FILE 433
#define RESV 434
#define RESV_EXEMPT 435
#define SECONDS 436
#define MINUTES 437
#define HOURS 438
#define DAYS 439
#define WEEKS 440
#define SENDQ 441
#define SEND_PASSWORD 442
#define SERVERHIDE 443
#define SERVERINFO 444
#define SERVICES 445
#define SERVICES_NAME 446
#define SERVLINK_PATH 447
#define IRCD_SID 448
#define TKLINE_EXPIRE_NOTICES 449
#define T_SHARED 450
#define T_CLUSTER 451
#define TYPE 452
#define SHORT_MOTD 453
#define SILENT 454
#define SPOOF 455
#define SPOOF_NOTICE 456
#define STATS_E_DISABLED 457
#define STATS_I_OPER_ONLY 458
#define STATS_K_OPER_ONLY 459
#define STATS_O_OPER_ONLY 460
#define STATS_P_OPER_ONLY 461
#define TBOOL 462
#define TMASKED 463
#define T_REJECT 464
#define TS_MAX_DELTA 465
#define TS_WARN_DELTA 466
#define TWODOTS 467
#define T_ALL 468
#define T_BOTS 469
#define T_SOFTCALLERID 470
#define T_CALLERID 471
#define T_CCONN 472
#define T_NOCTCP 473
#define T_CLIENT_FLOOD 474
#define T_DEAF 475
#define T_DEBUG 476
#define T_DRONE 477
#define T_EXTERNAL 478
#define T_FULL 479
#define T_HIDECHANNELS 480
#define T_FARCONNECT 481
#define T_INVISIBLE 482
#define T_IPV4 483
#define T_IPV6 484
#define T_LOCOPS 485
#define T_LOGPATH 486
#define T_L_CRIT 487
#define T_L_DEBUG 488
#define T_L_ERROR 489
#define T_L_INFO 490
#define T_L_NOTICE 491
#define T_L_TRACE 492
#define T_L_WARN 493
#define T_MAX_CLIENTS 494
#define T_NCHANGE 495
#define T_OPERWALL 496
#define T_REJ 497
#define T_SERVNOTICE 498
#define T_SKILL 499
#define T_SPY 500
#define T_SSL 501
#define T_UMODES 502
#define T_UNAUTH 503
#define T_UNRESV 504
#define T_UNXLINE 505
#define T_WALLOP 506
#define THROTTLE_TIME 507
#define THROTTLE_NUM 508
#define TOPICBURST 509
#define TRUE_NO_OPER_FLOOD 510
#define TKLINE 511
#define TXLINE 512
#define TRESV 513
#define UNKLINE 514
#define USER 515
#define USE_EGD 516
#define USE_EXCEPT 517
#define USE_INVEX 518
#define HIDE_KILLER 519
#define USE_REGEX_BANS 520
#define USE_KNOCK 521
#define USE_NOCTCP 522
#define USE_LOGGING 523
#define USE_WHOIS_ACTUALLY 524
#define VHOST 525
#define VHOST6 526
#define XLINE 527
#define WARN 528
#define WARN_NO_NLINE 529
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,    5,    5,    5,    5,    5,    5,    5,    5,
    5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
    5,    5,    5,    5,    5,    2,    2,    1,    1,    1,
    1,    1,    1,    4,    4,    3,    3,    3,    3,   25,
   27,   27,   28,   28,   28,   29,   30,   31,   26,   32,
   32,   33,   33,   33,   33,   34,   35,   36,   13,   37,
   37,   38,   38,   38,   38,   38,   38,   38,   38,   38,
   38,   38,   38,   49,   46,   39,   48,   42,   43,   44,
   40,   47,   45,   41,    6,   50,   50,   51,   51,   51,
   51,   52,   54,   53,    7,   55,   55,   56,   56,   56,
   56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
   57,   58,   61,   68,   62,   66,   63,   64,   67,   65,
   59,   59,   59,   59,   59,   59,   59,   60,   70,    8,
   69,   69,   71,   71,   73,   73,   73,   73,   73,   73,
   73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
   73,   73,   73,   73,   73,   73,   73,   73,   73,   74,
   72,   75,   95,   76,   93,   94,   80,   98,   79,   99,
   99,  100,  100,  100,  100,  100,  100,  100,  100,  100,
  100,  100,  100,  100,  100,  100,  100,  100,  100,  100,
  100,  100,   81,   82,   88,   83,   84,   85,   86,   87,
   89,   90,   91,   77,   78,   96,   92,  101,   97,  102,
  102,  105,  103,  106,  103,  104,  104,  104,  104,  104,
  104,  104,  104,  104,  104,  104,  104,  104,  104,  104,
  104,  104,  108,   10,  107,  107,  109,  109,  111,  111,
  111,  111,  111,  111,  111,  111,  111,  111,  111,  111,
  111,  111,  112,  110,  115,  116,  118,  119,  120,  121,
  122,  123,  124,  113,  114,  117,  125,   11,  128,  127,
  129,  129,  130,  130,  126,  126,  131,  131,  131,  131,
  131,  136,  132,  135,  135,  137,  137,  133,  134,  138,
   12,  139,  139,  140,  140,  140,  140,  140,  140,  140,
  140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
  140,  140,  141,  142,  158,  151,  143,  157,  159,  144,
  160,  160,  163,  161,  164,  161,  162,  162,  162,  162,
  162,  162,  162,  162,  162,  162,  162,  145,  146,  147,
  155,  148,  149,  150,  153,  154,  152,  156,  165,   15,
  166,  166,  167,  167,  167,  167,  168,  169,  170,  171,
   16,  172,  172,  173,  173,  173,  173,  174,  175,  177,
  176,  178,  178,  179,  179,  179,  179,  179,  179,  179,
  179,  179,  179,  179,  179,  179,  180,   17,  181,  181,
  182,  182,  182,  183,  185,  184,  186,  186,  187,  187,
  187,  187,  187,  187,  187,  187,  187,  187,  187,  189,
   18,  188,  188,  190,  190,  192,  192,  192,  192,  192,
  192,  192,  192,  192,  192,  192,  192,  192,  192,  192,
  192,  192,  192,  192,  192,  193,  191,  194,  195,  196,
  197,  199,  198,  198,  200,  212,  201,  213,  213,  216,
  214,  217,  214,  215,  215,  215,  215,  215,  215,  209,
  206,  208,  207,  205,  211,  202,  203,  204,  210,  218,
   19,  221,  220,  222,  222,  223,  219,  219,  224,  224,
  224,  224,  225,  226,  227,   20,  228,  228,  229,  229,
  229,  230,  231,   21,  232,  232,  233,  233,  233,  234,
  235,  236,   24,  239,  238,  240,  240,  241,  237,  237,
  242,  242,  242,  242,  243,  244,   22,  245,  245,  246,
  246,  246,  246,  246,  246,  246,  246,  246,  246,  246,
  246,  246,  246,  246,  246,  246,  246,  246,  246,  246,
  246,  246,  246,  246,  246,  246,  246,  246,  246,  246,
  246,  246,  246,  246,  246,  246,  246,  246,  246,  246,
  246,  246,  246,  246,  246,  246,  246,  246,  246,  246,
  246,  246,  246,  246,  246,  246,  246,  246,  246,  246,
  246,  246,  246,  300,  301,  298,  302,  303,  299,  258,
  247,  248,  287,  249,  250,  251,  252,  253,  254,  255,
  256,  257,  294,  259,  260,  305,  306,  307,  308,  309,
  261,  262,  289,  264,  269,  304,  265,  265,  267,  267,
  266,  281,  282,  268,  270,  271,  272,  273,  275,  274,
  263,  277,  286,  288,  290,  278,  279,  296,  297,  292,
  293,  310,  280,  311,  311,  312,  312,  312,  312,  312,
  312,  312,  312,  312,  312,  312,  312,  312,  312,  312,
  312,  312,  312,  312,  312,  312,  313,  276,  314,  314,
  315,  315,  315,  315,  315,  315,  315,  315,  315,  315,
  315,  315,  315,  315,  315,  315,  315,  315,  315,  315,
  315,  284,  285,  283,  291,  295,  316,   23,  317,  317,
  318,  318,  318,  318,  318,  318,  318,  319,  320,  325,
  321,  326,  326,  327,  327,  322,  323,  328,  324,  329,
  329,  330,  330,    9,  331,  331,  332,  332,  332,  332,
  332,  332,  332,  332,  332,  332,  332,  332,  332,  332,
  332,  332,  332,  332,  332,  332,  332,  332,  353,  352,
  347,  333,  334,  335,  338,  336,  337,  340,  341,  342,
  343,  339,  344,  345,  346,  348,  349,  350,  351,   14,
  354,  354,  355,  355,  355,  355,  355,  355,  355,  355,
  356,  357,  361,  358,  360,  359,  362,
};
short yylen[] = {                                         2,
    0,    2,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    2,    2,    0,    1,    2,    3,    3,
    3,    3,    3,    0,    1,    2,    3,    3,    3,    5,
    2,    1,    1,    1,    2,    4,    4,    0,    6,    2,
    1,    1,    1,    1,    2,    4,    4,    4,    5,    2,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    2,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    5,    2,    1,    1,    1,    1,
    2,    4,    4,    4,    5,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    0,    7,
    0,    1,    2,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    2,    4,
    1,    4,    4,    4,    4,    4,    4,    0,    5,    3,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    0,    5,    3,
    1,    0,    3,    0,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    0,    7,    0,    1,    2,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    2,    4,    1,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    0,    6,    0,    5,
    3,    1,    1,    1,    2,    1,    1,    1,    1,    1,
    2,    0,    5,    3,    1,    1,    3,    4,    4,    0,
    6,    2,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    2,    4,    4,    4,    4,    4,    4,    0,    5,
    3,    1,    0,    3,    0,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    0,    6,
    2,    1,    1,    1,    1,    2,    4,    4,    4,    0,
    6,    2,    1,    1,    1,    1,    2,    4,    4,    0,
    5,    3,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    0,    6,    2,    1,
    1,    1,    2,    4,    0,    5,    3,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    0,
    7,    0,    1,    2,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    2,    4,    1,    4,    4,    4,
    4,    4,    4,    4,    4,    0,    5,    3,    1,    0,
    3,    0,    2,    1,    1,    1,    1,    1,    1,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    0,
    6,    0,    5,    3,    1,    1,    2,    1,    1,    1,
    1,    1,    4,    4,    0,    6,    2,    1,    1,    1,
    1,    4,    4,    5,    2,    1,    1,    1,    1,    4,
    4,    0,    6,    0,    5,    3,    1,    1,    2,    1,
    1,    1,    1,    1,    4,    4,    5,    2,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    0,    5,    3,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    0,    5,    3,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    4,    4,    4,    4,    4,    0,    6,    2,    1,
    1,    1,    1,    1,    1,    1,    1,    4,    4,    0,
    5,    3,    1,    1,    1,    4,    4,    0,    5,    3,
    1,    1,    1,    5,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    5,
    2,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    4,    4,    4,    4,    4,    4,    4,
};
short yydefred[] = {                                      1,
    0,    0,    0,    0,  233,  410,  485,   48,    0,  502,
    0,  697,  290,  470,  267,    0,    0,  129,  349,    0,
    0,  360,  387,    2,    3,    4,    5,    6,    7,    8,
    9,   10,   11,   12,   13,   14,   15,   16,   17,   18,
   19,   20,   21,   22,   23,   24,   25,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   87,   88,   89,   90,  748,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  726,  727,  728,  729,  730,  731,  732,  733,  734,  735,
  736,  737,  738,  739,  740,  741,  742,  743,  744,  745,
  746,  747,  254,    0,  236,  437,    0,  413,    0,    0,
  499,    0,    0,    0,  496,  497,  498,    0,  583,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  667,    0,  642,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  519,  520,  521,  522,  523,  524,  525,
  526,  527,  528,  529,  530,  531,  532,  533,  534,  535,
  536,  537,  538,  539,  540,  541,  542,  543,  544,  545,
  546,  547,  548,  549,  550,  551,  552,  553,  554,  555,
  556,  557,  558,  559,  560,  561,  562,  563,  564,  565,
  566,  567,  568,  569,  570,  571,  572,  573,  574,  575,
  576,  577,  578,  579,  580,  581,  582,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   97,   98,   99,  100,  101,
  102,  103,  104,  105,  106,  107,  108,  109,    0,    0,
    0,    0,   42,   43,   44,  161,    0,  132,    0,  780,
    0,    0,    0,    0,    0,    0,    0,    0,  772,  773,
  774,  775,  776,  777,  778,  779,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   61,
   62,   63,   64,   65,   66,   67,   68,   69,   70,   71,
   72,    0,    0,   91,    0,    0,    0,    0,   86,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  725,    0,    0,  491,    0,    0,    0,  488,  489,
  490,    0,    0,    0,    0,    0,   51,   52,   53,   54,
    0,    0,    0,  495,  514,    0,    0,  504,    0,  513,
  510,  511,  512,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  518,  707,  718,
    0,    0,  710,    0,    0,    0,  700,  701,  702,  703,
  704,  705,  706,    0,    0,    0,    0,    0,    0,  319,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,  303,  304,  305,  306,  307,  308,  309,
  310,  311,  482,    0,  472,    0,    0,  481,  478,  479,
  480,    0,  269,    0,    0,    0,    0,  278,  276,  277,
  279,  280,  110,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   96,   45,    0,    0,
    0,   41,    0,    0,    0,    0,    0,    0,  352,  353,
  354,  355,    0,    0,    0,    0,    0,    0,    0,    0,
  771,   73,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   60,    0,    0,  370,    0,    0,
  363,  364,  365,  366,    0,    0,  395,    0,  390,  391,
  392,    0,    0,    0,   85,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  724,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  238,  239,  240,  241,  242,  243,  244,
  245,  246,  247,  248,  249,  250,  251,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  446,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  415,  416,
  417,  418,  419,  420,  421,  422,  423,  424,  425,  426,
  427,  428,  429,  430,  431,  432,  433,  434,    0,    0,
    0,  487,   55,    0,    0,    0,    0,   50,    0,    0,
  494,    0,    0,    0,    0,  509,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  517,    0,    0,    0,    0,    0,    0,    0,
  699,  312,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  292,    0,    0,    0,    0,  477,  281,    0,    0,
    0,    0,    0,  275,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   95,    0,    0,   40,    0,    0,    0,    0,
    0,    0,  208,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  168,    0,    0,
    0,    0,  134,  135,  136,  137,  138,  139,  140,  141,
  142,  143,  144,  145,  146,  147,  148,  149,  150,  151,
  152,  153,  154,  155,  156,  157,  158,  356,    0,    0,
    0,    0,  351,    0,    0,    0,    0,    0,    0,    0,
  770,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   59,  367,    0,    0,    0,    0,  362,  393,
    0,    0,    0,  389,   94,   93,   92,  767,  749,  764,
  763,  750,  752,    0,    0,    0,    0,    0,   27,   28,
  758,  759,  762,  760,  765,  766,  768,  769,  761,  751,
  753,  754,  755,  756,  757,  252,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  237,  435,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  414,    0,    0,  486,    0,    0,    0,   49,
  501,  500,    0,    0,    0,  503,  595,  599,  600,  586,
  622,  606,  607,  608,  609,  635,  634,  694,  639,  593,
  696,  631,  637,  594,  584,  585,  603,  591,  630,  592,
  611,  590,  605,  604,  598,  597,  596,  632,  629,  692,
  693,  626,  623,  671,  687,  688,  672,  673,  674,  675,
  682,  676,  690,  691,  685,  689,  678,  683,  679,  684,
  677,  681,  680,  686,    0,  670,  628,  646,  662,  663,
  647,  648,  649,  650,  657,  651,  665,  666,  660,  664,
  653,  658,  654,  659,  652,  656,  655,  661,    0,  645,
  621,  624,  638,  588,  610,  633,  589,  625,  613,  619,
  620,  617,  618,  614,  615,  602,  601,    0,    0,    0,
   35,   36,  695,  641,  640,  627,  636,  616,  587,  612,
    0,    0,    0,    0,    0,    0,  698,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  291,    0,    0,    0,  471,
    0,    0,    0,    0,    0,  285,  268,  114,  120,  118,
  117,  119,  115,  116,  113,  121,  127,  122,  126,  124,
  125,  123,  112,  111,  128,   46,   47,  159,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  133,    0,    0,    0,  350,  786,  781,
  785,  783,  787,  782,  784,   78,   84,   76,   80,   79,
   75,   74,   77,   83,   81,   82,    0,    0,    0,  361,
    0,    0,  388,   29,   30,   31,   32,   33,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  234,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  411,  492,  493,   57,   56,   58,  515,  516,
  508,    0,  507,  668,    0,  643,    0,   37,   38,   39,
  723,  722,    0,  721,  709,  708,  715,  714,    0,  713,
  717,  716,  341,  317,  315,  318,  340,  323,    0,  322,
    0,  343,  339,  338,  348,  347,  342,  314,  346,  345,
  344,  316,  313,  484,  476,    0,  475,  483,  274,  273,
    0,  272,  289,  288,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  130,  358,  359,  357,  368,  374,  385,  380,  384,
  386,  383,  382,  379,  375,  378,  381,  376,  377,    0,
  373,  369,  394,  399,  405,  409,  408,  407,  404,  400,
  403,  406,  401,  402,    0,  398,  264,  265,  258,  260,
  262,  261,  259,  253,  266,  257,  255,  256,  263,  441,
  443,  444,  464,  469,  468,  463,  462,  461,  445,  450,
    0,  449,    0,  438,  466,  467,  436,  442,  460,  440,
  465,  439,  505,    0,  669,  644,  719,    0,  711,    0,
    0,  320,    0,  331,  332,  328,  334,  330,  329,  337,
  336,  333,  335,  327,  326,  473,    0,  270,    0,  287,
  284,  283,  203,  167,  163,  201,  165,  212,    0,  211,
    0,  199,  193,  204,  205,  196,  160,  200,  206,  164,
  202,  194,  195,  166,  207,  172,  188,  189,  173,  174,
  175,  176,  183,  177,  191,  192,  186,  190,  179,  184,
  180,  185,  178,  182,  181,  187,    0,  171,  198,  162,
  197,  371,    0,  396,    0,    0,  447,    0,  457,  458,
  455,  456,  454,  459,  453,  506,  720,  712,  324,  321,
  474,  271,    0,  209,    0,  224,  222,  231,  221,  216,
  225,  229,  218,  226,  228,  232,  223,  217,  230,  227,
  219,  220,  215,  169,    0,  372,  397,  451,  448,  213,
  210,  170,
};
short yydgoto[] = {                                       1,
  969,  970, 1141, 1142,   24,   25,   26,   27,   28,   29,
   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,
   40,   41,   42,   43,   44,   45,  302,  303,  304,  305,
   53,  396,  397,  398,  399,  400,  339,  340,  341,  342,
  343,  344,  345,  346,  347,  348,  349,  350,  351,   73,
   74,   75,   76,   77,  285,  286,  287,  288,  289,  290,
  291,  292,  293,  294,  295,  296,  297,  298,  307,   63,
  892,  308,  893,  894,  895,  896,  897,  898,  899,  900,
  901,  902,  903,  904,  905,  906,  907,  908,  909,  910,
  911,  912,  913,  914,  915,  916,  917, 1229, 1537, 1538,
 1214, 1499, 1500, 1583, 1563, 1501,  124,   50,  663,  125,
  664,  665,  666,  667,  668,  669,  670,  671,  672,  673,
  674,  675,  676,  677,   60,  547,  548,  839, 1361, 1362,
  549,  550,  551,  552, 1185, 1367, 1186,   58,  513,  514,
  515,  516,  517,  518,  519,  520,  521,  522,  523,  524,
  525,  526,  527,  528,  529,  530,  531,  532,  818, 1339,
 1340, 1485, 1471, 1341,   64,  578,  579,  580,  581,  582,
   67,  610,  611,  612,  613,  614,  946, 1410, 1411,   68,
  618,  619,  620,  621,  952, 1425, 1426,  127,   51,  698,
  128,  699,  700,  701,  702,  703,  704,  705,  706,  707,
  708,  709,  710,  711,  712,  713,  714,  715,  716,  717,
  718, 1012, 1451, 1452, 1555, 1546, 1453,   59,  537,  538,
  834, 1356, 1357,  539,  540,  541,   52,  388,  389,  390,
  391,  134,  135,  136,  137,   55,  409,  410,  734, 1312,
 1313,  411,  412,  413,  203,  204,  205,  206,  207,  208,
  209,  210,  211,  212,  213,  214,  215,  216,  217,  218,
  219,  220,  221,  222,  223,  224,  225,  226,  227,  228,
  229,  230,  231,  232,  233,  234,  235,  236,  237,  238,
  239,  240,  241,  242,  243,  244,  245,  246,  247,  248,
  249,  250,  251,  252,  253,  254,  255,  256,  257,  258,
  259,  260,  261,  262,  263,  264,  265,  266,  267,  453,
 1119, 1120,  451, 1095, 1096,   57,  486,  487,  488,  489,
  490,  491,  492,  493,  807, 1329, 1330,  804, 1323, 1324,
  100,  101,  102,  103,  104,  105,  106,  107,  108,  109,
  110,  111,  112,  113,  114,  115,  116,  117,  118,  119,
  120,  121,  122,  318,  319,  320,  321,  322,  323,  324,
  325,  326,
};
short yysindex[] = {                                      0,
  827,  -45,  -83,  -79,    0,    0,    0,    0,  -77,    0,
  -65,    0,    0,    0,    0,  -60,  -54,    0,    0,  -47,
  -28,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, -214,  658, -398,
 -320,  -23,  -20, -229,  -10,  400,    2,    4,    5,   10,
  267, -209, -311,   23,  538,  166,   27,   36,  101,  106,
  107,  116, -107,    0,    0,    0,    0,    0,  118,  119,
  120,  125,  127,  135,  136,  147,  148,  149,  157,  158,
  159,  161,  165,  170,  173,  174,  177,  178,  179,  137,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   81,    0,    0,  104,    0, -247, -226,
    0,  182,  184,  -57,    0,    0,    0, -231,    0,  188,
  190,  194,  199,  200,  202,  203,  214,  217,  220,  227,
  233,  234,  237,  238,  254,  257,  259,  261,  268,  269,
  273,  284,  287,  288,  289,  290,  296,  305,  307,  315,
  316,  318,  319,  322,  323,  326,    0,  329,    0,  331,
  340,  343,  345,  348,  350,  353,  354,  357,  358,  359,
  360,  365,  367,  370,  374,  375,  376,  382,  383,  384,
  385,  386, -122,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, -246,  764, -245,
 -224,  389,  391,  395,  396,  397,  401,  402,  404,  405,
  406,  407,  408,  409,  -14,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  414,  413,
  417,  -91,    0,    0,    0,    0,  356,    0, -220,    0,
  419,  421,  422,  423,  424,  425,  428,  380,    0,    0,
    0,    0,    0,    0,    0,    0,  432,  434,  440,  443,
  449,  450,  452,  454,  455,  456,  460,  463,   -6,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -241, -237,    0,   22,  111,  117,  466,    0,   64,
   73,  141,  144,   79,   82,  152,  152,  155,  160,   83,
   93,  162,  152,   98,  100,  102,  105,  108,  109,  110,
  480,    0,  828,  505,    0,  482,  502, -121,    0,    0,
    0,  509,  508,  512,  513, -108,    0,    0,    0,    0,
  175,  176,  517,    0,    0,  516,  518,    0, -105,    0,
    0,    0,    0,  122,  152,  134,  142,  152,  186,  193,
  197,  151,  185,  198,  207,  156,  163,  168,  225,  218,
  171,  226,  242,  243,  183,  152,  187,  189,  244,  222,
  191,  250,  251,  152,  252,  231,  265,  270,  209,  210,
  519,  211,  537,  152,  152,  213,  152,  246,  260,  216,
  219,  228, -425, -396,  235,  239,  152,  152,  291,  152,
  293,  240,  241,  248,  249,  255,  610,    0,    0,    0,
  619,  635,    0,  638,  644, -119,    0,    0,    0,    0,
    0,    0,    0,  636,  647,  651,  652,  653,  655,    0,
  657,  660,  662,  665,  666,  667,  668,  669,  670,  671,
  672,  676,  221,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  677,    0,  679, -120,    0,    0,    0,
    0,  682,    0,  681,  684,  686, -101,    0,    0,    0,
    0,    0,    0,  300,  324,  330,  335,  337,  338,  341,
  349, -128,  352,  355,  286,  705,    0,    0,  363,  364,
  708,    0,  507,  713,  712,  716,  723, -102,    0,    0,
    0,    0,  325,  333,  336,  372,  339,  347,  152,  738,
    0,    0,  381,  351,  388,  399,  410,  411,  412,  415,
  403,  416,  418,  744,    0,  751,  753,    0,  755,  -99,
    0,    0,    0,    0,  761,  762,    0, -112,    0,    0,
    0,  766,  768,  769,    0,  773,  774,  779,  780,  782,
  783, -322,  785,  786,  792,  796,  803,  805,  808,  810,
  811,  812,  813,  814,  816,  817,  818,    0,  820,  823,
  825,  826,  829,  831,  833,  834,  835,  837,  838,  839,
  840,  842,   77,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  822,  843,  844,
  845,  848,  850,  851,  854,  856,  857,    0,  860,  861,
  866,  867,  869,  870,  875,  879,  880,  143,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  469,  523,
  884,    0,    0,  152,  525,  526,  889,    0,  890,  892,
    0,  533,  539,  895,  901,    0,  905,  906,  907,  909,
  912,  913,  914,  915,  917,  919,  920,  921,  922,  924,
  925,  926,  927,  928,  929,  930,  932,  933,  934,  935,
  936,  937,  938,  939,  940,  941,  942,  943,  945,  946,
  947,  948,  949,  824,  951,  865,  952,  953,  954,  956,
  958,  964,  966,  967,  968,  972,  976,  977,  978,  979,
  983,  984,  985, -198,  988,  989,  993,  996,  997,  998,
  999, 1001,    0,  896,  152,  601, 1003,  646,  650, 1007,
    0,    0,  608,  654,  656,  609,  612, 1011,  617,  618,
  620,  623,  627,  628,  673,  692,  674,  675,  629,  678,
 1037,    0,  680, 1039,  690, 1042,    0,    0, 1044,  691,
  693,  702, 1052,    0, 1054, 1055, 1056, 1058, 1060, 1061,
 1064, 1066, 1067, 1070, 1072, 1074, 1075, 1076, 1077, 1078,
 1079, 1080,    0, 1083, 1084,    0, 1085, 1086, 1090, 1091,
 1095, 1098,    0, 1099, 1101, 1102, 1105, 1106, 1107, 1108,
 1109, 1110, 1111, 1121, 1123, 1124, 1127,    0, 1128, 1130,
 1132,  -15,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  726,  727,
  776, 1137,    0, 1138, 1139, 1140, 1144, 1145, 1147, 1148,
    0, 1149, 1154, 1155, 1156, 1157, 1158, 1159, 1162, 1163,
 1164, 1165,    0,    0,  806, 1169,  815, 1172,    0,    0,
  821, 1171, 1174,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  152,  152,  152,  152,  152,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  707,  846,  152,  847,
  853,  855,  858,  841,  862,  863,  152,  152,  291, 1176,
    0,    0,  849, -397,  777,  871,  872,  788,  790,  791,
  882, 1180,  888,  891,  893,  894,  868,  897,  899,  794,
  910, 1188,    0, 1189, 1198,    0, 1203, 1204, 1206,    0,
    0,    0, 1207, 1208,  864,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  -16,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  -11,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  291,  291,  291,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -258, 1213, 1214, -250, 1215, 1216,    0, 1217, 1221, 1222,
 1223, 1226,  916, 1227, 1230, 1239, 1255, 1256, 1258, 1266,
 1267, 1269, 1272, 1273, 1280,    0, 1283,  931, 1289,    0,
 -318, 1290, 1292,  885, 1309,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  904,  950,
  961,  908,  955, 1295,  957,  959,  960,  962,  963,  970,
  965,  969,  971,  973,  974,  975,  986,  980, 1296,  981,
  991,  982, 1299,    0, 1300, 1308, 1318,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0, 1327,   97, 1328,    0,
 1332,  115,    0,    0,    0,    0,    0,    0, 1333, 1334,
 1335, 1336, 1337, 1338, 1345, 1348, 1349, 1352, 1353, 1354,
 1355,    0, 1356, 1357, 1359, 1361, 1364, 1367, 1369, 1370,
 1371, 1373, 1038, 1375, 1379, 1380, 1381, 1382, 1386, 1387,
 1388, 1389,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   -9,    0,    0,  824,    0,  865,    0,    0,    0,
    0,    0,   -5,    0,    0,    0,    0,    0,   -3,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    1,    0,
  852,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   20,    0,    0,    0,    0,
   31,    0,    0,    0, 1053,  702, 1391, 1392, 1393, 1394,
 1395, 1396, 1062, 1397, 1399, 1400, 1401, 1402, 1403, 1404,
 1405, 1406, 1407, 1408, 1409, 1410, 1411,  903, 1412, 1413,
 1414,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   33,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   39,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   50,    0, -236,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  864,    0,    0,    0, -258,    0, -250,
  852,    0,  916,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  931,    0, -318,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   53,    0,
  626,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   61,    0,    0,    0,
    0,    0,   97,    0,  115, -236,    0, 1038,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  626,    0, 1062,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  903,    0,    0,    0,    0,    0,
    0,    0,
};
short yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, 1351,
 1358,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, 1360,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, 1416,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, 1417,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, 1416, 1416, 1416, 1416, 1416,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, 1417, 1417, 1417,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  898,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   63, 1418,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, -206,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  634,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  898,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, -206,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  634,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,
};
short yygindex[] = {                                      0,
 -366, -594, -467,-1008,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, 1177,    0,    0,
    0,    0, 1082,    0,    0,    0,    0, 1141,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 1415,    0,    0,    0,    0, 1197,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  592,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -100,
    0,    0,  -78,  -74,    0,    0,    0,    0,    0,    0,
  830,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    3,
  944,    0,    0,    0,    0,    0,  124,    0,    0,  987,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   13,   24,    0,    0,    0,    0,  918,    0,    0,    0,
    0,    0,  887,    0,    0,    0,    0,    0,  -49,    0,
    0,  881,    0,    0,    0,    0,  -44,    0,    0,    0,
    0,  800,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  -46,  -43,    0,    0,    0,    0,    0,
    0,    0,   17,  990,    0,    0,    0,    0, 1117,    0,
    0,    0, 1372,    0,    0,    0,    0,    0,    0,    0,
   43, 1100,    0,    0,    0, 1305,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  195,    0,    0,  196,    0,    0, 1024,    0,    0,
    0,    0,    0,    0,    0,    0,   44,    0,    0,   45,
    0, 1419,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0, 1199,    0,    0,    0,    0,    0,
    0,    0,
};
#define YYTABLESIZE 1527
short yytable[] = {                                     633,
  634,  795,  477,  721,  836,  810,  640, 1321,  385,  479,
  533,  480,  953,   46,  606, 1327,  727,  358,  615,  735,
  123, 1359,  922,  843,  405,  948,  131, 1315, 1549,  392,
 1550,  542, 1317,  571, 1464,  574,  786,  787, 1468,   48,
 1470,   69, 1314,   49, 1473,   54,  299, 1316,  738, 1463,
 1551,  741,  132, 1467, 1552, 1469,  575,   56,  452, 1472,
  452,  481,   61, 1487,  482,  788,  789,  403,   62,  759,
 1138, 1139, 1140,  632, 1489,   65, 1543,  767, 1486,   47,
  452,  393, 1545,   70,  452, 1284, 1285,  777,  778, 1488,
  780, 1542,  543, 1548,   66,   71, 1565, 1544,  126,  129,
  792,  793,  130,  796, 1585,  386,  286,  306, 1547, 1233,
  566, 1564,  138,  964,  965,  966,  967,  968,  604, 1584,
  483,  286,  544,  133,  268, 1553,  269,  270,  545, 1318,
 1319, 1320,  271,  139,  385,  533,  479,  484,  480,  140,
  141,  142,  607,  615,  143,  309,  616,  392,   69,  352,
  405,  144,  406,  574,  542,  452,  606,  394,  353,  354,
  145,  146,  147,  148,  299,  149,  355,  356,  576,   72,
  150,  151,  300,  387,  575,  534,  357,  152,  360,  361,
  362,  153, 1360,  154,  155,  363,  156,  364,  481,  407,
   70,  482,  157,  546,  395,  365,  366,  794,  131,  393,
  577, 1000,   71,  383,  301, 1322,  535,  367,  368,  369,
  608,  158,  159, 1328,  617,  543,  160,  370,  371,  372,
  408,  373,  930,  161,  132,  374,  384,  162,  163,  164,
  375,  386,  165,  376,  377,  166,  167,  378,  379,  380,
  867,  272,  401,  868,  402,  544,  168,  483,  414,  327,
  415,  545,  169,  170,  416,  171,  172,  173,  174,  417,
  418,  381,  419,  420,  484,  869,  870, 1022,  485,  536,
  175,  616, 1554,  609,  421,  394,   72,  422,  406,  176,
  423,  177,  178,  871,  607,  179,  576,  424,  180,  181,
  300,  328,  182,  425,  426,  133,  872,  427,  428,  387,
  534,  873,  452,  183,  273,  274,  275,  276,  277,  278,
  279,  280,  395,  874,  429,  407,  546,  430,  577,  431,
  875,  432,  301,  184,  185,  876,  186,  877,  433,  434,
  187,  535,  649,  435,  188,  189,  190,  191,  192,  617,
  878,  329,  193,  194,  436,  831,  408,  437,  438,  439,
  440,  195,  608,  281,  650,  651,  441, 1027,  853,  854,
  855,  856,  857,  858,  859,  442,  652,  443,  879, 1264,
 1265, 1266, 1267, 1268,  880,  444,  445,  330,  446,  447,
  331,  332,  448,  449,  196,  197,  450,  198,  282,  452,
  881,  454,   78,  199,  536,  485,  200,  882,  678,  679,
  455,  201,  680,  456,   79,  457,  202,  681,  458,  883,
  459,  884,  885,  460,  461,  609,  886,  462,  463,  464,
  465,  327,  682,  683,  333,  466,  334,  467,   80,  684,
  468,   81,   82,  685,  469,  470,  471,   83, 1152,   84,
  622,  335,  472,  473,  474,  475,  476,  553,  653,  654,
  655,  554, 1397,  656,  686,  555,  556,  557,  687,  688,
  657,  558,  559,  328,  560,  561,  562,  563,  564,  565,
 1414,  283,  568,  569,  658,  659,  494,  570,  573,  583,
  887,  584,  585,  586,  587,  588,  888,  336,  589,  689,
  592,  690,  660,  661,  593,  495,   85,   86,  889,  890,
  594,  496,  497,  595,  590,  691,   87,   88,  284,  596,
  597,  891,  598,  329,  599,  600,  601,  662,  337,  338,
  602, 1398,  272,  603,  625,  626,  692,   89,   90,  623,
 1399, 1281,  498,  499,  627,  624,  628,  500,  648,  629,
  630, 1400,  719,  631,  637,   91,   92,  632, 1415,  330,
  635,  501,  331,  332,  638,  636,   93,  639,  502,  641,
  693,  642,  720,  643, 1401,   94,  644,  723,  724,  645,
  646,  647,  725,  726,  694,  731,  732,  503,  733,  774,
  746, 1402, 1416,  737,  695,  273,  274,  275,  276,  277,
  278,  279,  280,  729,  730,  739,  333,  776,  334, 1417,
 1403, 1404,  748,  740,  742,  504,  505, 1405, 1406, 1407,
 1408,  743,  745,  335,  506,  744,  747,  749, 1418, 1419,
  752,  755, 1271, 1409,  750, 1420, 1421, 1422, 1423,  751,
 1279, 1280,  754,  507,  281,  310,  753,  756,  757,  762,
  763, 1424,  508,  509,  758,  765,  766,  768,  760,  769,
  761,  696,  764,   95,   96,  139,   97,   98,   99,  336,
  770,  140,  141,  142,  781,  771,  143,  697,  803,  282,
  772,  773,  775,  144,  779,  510,  511,  783,  782,  805,
  784,  311,  145,  146,  147,  148,  794,  149,  797,  785,
  337,  338,  150,  151,  812,  806,  790,  312,  808,  152,
  791,  798,  799,  153,  809,  154,  155,  813,  156,  800,
  801,  814,  815,  816,  157,  817,  802,  819,  845,  313,
  820,  314,  821,  315,  316,  822,  823,  824,  825,  826,
  827,  828,  829,  158,  159,  512,  830,  833,  160,  835,
  838,  840,  846,  317,  841,  161,  842,  862,  847,  162,
  163,  164,  283,  848,  165,  849,  850,  166,  167,  851,
  678,  679,  867,  863,  680,  868,  866,  852,  168,  681,
  860,  918,  919,  861,  169,  170,  920,  171,  172,  173,
  174,  864,  865,  921,  682,  683,  924,  869,  870,  284,
  927,  684,  175,  310,  925,  685,  931,  926,  940,  932,
  928,  176,  943,  177,  178,  871,  934,  179,  929,  944,
  180,  181,  933,  945,  182,  947,  686,  935,  872,  950,
  687,  688,  951,  873,  955,  183,  956,  957,  936,  937,
  938,  958,  959,  939,  941,  874,  942,  960,  961,  311,
  962,  963,  875,  971,  972,  184,  185,  876,  186,  877,
  973,  689,  187,  690,  974,  312,  188,  189,  190,  191,
  192,  975,  878,  976,  193,  194,  977,  691,  978,  979,
  980,  981,  982,  195,  983,  984,  985,  313,  986,  314,
 1002,  315,  316,  987, 1566,  988,  989, 1024,  692,  990,
  879,  991,  214,  992,  993,  994,  880,  995,  996,  997,
  998,  317,  999, 1003, 1004, 1005,  196,  197, 1006,  198,
 1007, 1008,  881,   78, 1009,  199, 1010, 1011,  200,  882,
 1013, 1014,  693,  201, 1567,   79, 1015, 1016,  202, 1017,
 1018,  883,  214,  884,  885, 1019,  694, 1568,  886, 1020,
 1021, 1025, 1026, 1028, 1029,  214,  695, 1030, 1031,   80,
 1032, 1033,   81,   82, 1569, 1035, 1151, 1034,   83, 1036,
   84, 1570,  214, 1037, 1038, 1039, 1571, 1040, 1572,  214,
 1041, 1042, 1043, 1044,  214, 1045,  214, 1046, 1047, 1048,
 1049, 1573, 1050, 1051, 1052, 1053, 1054, 1055, 1056,  214,
 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066,
 1067, 1068,  887, 1069, 1070, 1071, 1072, 1073,  888, 1097,
 1121, 1122, 1123,  696, 1124, 1574, 1125,   85,   86,  494,
  889,  890, 1126,  214, 1127, 1128, 1129,   87,   88,  697,
 1130, 1575, 1576,  891, 1131, 1132, 1133, 1134,  495,  214,
  214, 1135, 1136, 1137,  496,  497, 1143, 1144,   89,   90,
 1577, 1145, 1578, 1579, 1146, 1147, 1148, 1149,  214, 1150,
  214,  214, 1153, 1154, 1155, 1157,   91,   92, 1156, 1158,
 1161, 1163, 1159, 1162, 1160,  498,  499,   93, 1164, 1165,
  500, 1166,    2,  649, 1167,    3,   94, 1171, 1168, 1169,
 1174, 1170, 1172, 1173,  501, 1176, 1175, 1184, 1177, 1178,
 1180,  502, 1269,    4, 1181,  650,  651,    5, 1179, 1182,
 1187, 1183, 1188, 1189, 1190,    6, 1191,  652, 1192, 1193,
  503, 1580, 1194,    7, 1195, 1196, 1474, 1475, 1197,  214,
 1198,    8, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1581,
    9, 1206, 1207, 1208, 1235, 1236, 1209,  214,  504,  505,
 1210, 1211, 1582,   10,   11, 1212,   12,  506, 1213, 1215,
  214, 1216, 1217,   13, 1476, 1218, 1219, 1220, 1221, 1222,
 1223, 1224,  325,  325,   95,   96,  507,   97,   98,   99,
   14, 1225, 1477, 1226, 1227,  508,  509, 1228, 1230, 1478,
 1231,   15, 1232,   16, 1237, 1238, 1239, 1240, 1241,  653,
  654,  655, 1242, 1243,  656, 1244, 1245, 1246, 1479,   17,
  325,  657, 1247, 1248, 1249, 1250, 1251, 1252,  510,  511,
 1253, 1254, 1255, 1256, 1257,  658,  659,   18,  325, 1258,
 1260, 1262, 1263, 1259, 1282,  325, 1480, 1481, 1286, 1261,
 1293, 1270, 1272,  660,  661, 1482, 1303, 1304, 1273, 1289,
 1274, 1290, 1291, 1275,  325, 1301, 1305, 1277, 1278, 1276,
   19, 1306, 1307, 1298, 1308, 1309, 1310, 1283,  662,   20,
   21, 1325, 1326, 1331, 1332, 1333,   22,   23,  512, 1334,
 1335, 1336,  325,  325, 1337, 1342, 1483, 1311, 1343, 1287,
 1288,  325, 1074, 1075, 1076, 1077, 1078, 1344, 1079, 1080,
 1292, 1081, 1082, 1083, 1084, 1085, 1294, 1484, 1086, 1295,
 1338, 1296, 1297, 1345, 1346, 1299, 1347, 1300, 1087, 1088,
 1089, 1090, 1091, 1092, 1348, 1349, 1093, 1350, 1302, 1094,
 1351, 1352,  325, 1098, 1099, 1100, 1101, 1102, 1353, 1103,
 1104, 1354, 1105, 1106, 1107, 1108, 1109, 1358, 1363, 1110,
 1364, 1365, 1366,  325, 1355, 1373, 1388, 1392, 1393, 1111,
 1112, 1113, 1114, 1115, 1116, 1368, 1394, 1117, 1369, 1371,
 1118, 1516, 1517, 1518, 1519, 1520, 1395, 1521, 1522, 1370,
 1523, 1524, 1525, 1526, 1527, 1396, 1412, 1528, 1379, 1382,
 1413, 1427, 1428, 1429, 1430, 1431, 1432, 1529, 1530, 1531,
 1532, 1533, 1534, 1433, 1386, 1535, 1434, 1435, 1536, 1390,
 1436, 1437, 1438, 1439, 1440, 1441, 1372, 1442, 1374, 1443,
 1375, 1376, 1444, 1377, 1378, 1445, 1380, 1446, 1447, 1448,
 1381, 1449, 1450, 1454, 1383, 1384, 1385, 1455, 1456, 1457,
 1458, 1387, 1389, 1391, 1459, 1460, 1461, 1462, 1490, 1492,
 1493, 1494, 1495, 1496, 1497, 1502, 1498, 1503, 1504, 1505,
 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515,
 1539, 1540, 1541,  235,   26,   34,  282,  728,  572,  605,
  412,  567,  131, 1234, 1592, 1560, 1591,  359, 1590, 1491,
  844, 1562, 1001, 1586, 1559,  923,  949, 1023,  954,  832,
 1587, 1589, 1588, 1561,  722,  404, 1556,  478,  736,  811,
 1465, 1466, 1557, 1558,    0,    0,  591,    0,  382,    0,
    0,    0,    0,    0,    0,    0,  837,
};
short yycheck[] = {                                     366,
  367,  469,  125,  125,  125,  125,  373,  266,  256,  256,
  256,  258,  125,   59,  256,  266,  125,  125,  256,  125,
  419,  340,  125,  125,  256,  125,  256,   44,  265,  256,
  267,  256,   44,  125,   44,  256,  462,  463,   44,  123,
   44,  256,   59,  123,   44,  123,  256,   59,  415,   59,
  287,  418,  282,   59,  291,   59,  277,  123,  265,   59,
  267,  308,  123,   44,  311,  462,  463,  125,  123,  436,
  269,  270,  271,  396,   44,  123,   44,  444,   59,  125,
  287,  308,   44,  298,  291,  483,  484,  454,  455,   59,
  457,   59,  317,   44,  123,  310,   44,   59,  419,  123,
  467,  468,  123,  470,   44,  353,   44,  419,   59,  125,
  125,   59,  123,  436,  437,  438,  439,  440,  125,   59,
  367,   59,  347,  353,  123,  362,  123,  123,  353, 1138,
 1139, 1140,  123,  256,  256,  256,  256,  384,  258,  262,
  263,  264,  384,  256,  267,  123,  384,  256,  256,  123,
  256,  274,  384,  256,  256,  362,  256,  384,  123,   59,
  283,  284,  285,  286,  256,  288,   61,   61,  389,  384,
  293,  294,  382,  421,  277,  421,   61,  300,   61,   61,
   61,  304,  501,  306,  307,   61,  309,   61,  308,  421,
  298,  311,  315,  418,  421,   61,   61,  396,  256,  308,
  421,  125,  310,  123,  414,  464,  452,   61,   61,   61,
  452,  334,  335,  464,  452,  317,  339,   61,   61,   61,
  452,   61,  589,  346,  282,   61,  123,  350,  351,  352,
   61,  353,  355,   61,   61,  358,  359,   61,   61,   61,
  256,  256,   61,  259,   61,  347,  369,  367,   61,  256,
   61,  353,  375,  376,   61,  378,  379,  380,  381,   61,
   61,  125,   61,   61,  384,  281,  282,  125,  515,  515,
  393,  384,  509,  515,   61,  384,  384,   61,  384,  402,
   61,  404,  405,  299,  384,  408,  389,   61,  411,  412,
  382,  298,  415,   61,   61,  353,  312,   61,   61,  421,
  421,  317,  509,  426,  319,  320,  321,  322,  323,  324,
  325,  326,  421,  329,   61,  421,  418,   61,  421,   61,
  336,   61,  414,  446,  447,  341,  449,  343,   61,   61,
  453,  452,  256,   61,  457,  458,  459,  460,  461,  452,
  356,  348,  465,  466,   61,  125,  452,   61,   61,   61,
   61,  474,  452,  368,  278,  279,   61,  724,  487,  488,
  489,  490,  491,  492,  493,   61,  290,   61,  384,  964,
  965,  966,  967,  968,  390,   61,   61,  384,   61,   61,
  387,  388,   61,   61,  507,  508,   61,  510,  403,   61,
  406,   61,  256,  516,  515,  515,  519,  413,  256,  257,
   61,  524,  260,   61,  268,   61,  529,  265,   61,  425,
   61,  427,  428,   61,   61,  515,  432,   61,   61,   61,
   61,  256,  280,  281,  431,   61,  433,   61,  292,  287,
   61,  295,  296,  291,   61,   61,   61,  301,  805,  303,
  419,  448,   61,   61,   61,   61,   61,   59,  372,  373,
  374,   61,  356,  377,  312,   61,   61,   61,  316,  317,
  384,   61,   61,  298,   61,   61,   61,   61,   61,   61,
  356,  486,   59,   61,  398,  399,  256,   61,  123,   61,
  496,   61,   61,   61,   61,   61,  502,  494,   61,  347,
   59,  349,  416,  417,   61,  275,  360,  361,  514,  515,
   61,  281,  282,   61,  125,  363,  370,  371,  523,   61,
   61,  527,   61,  348,   61,   61,   61,  441,  525,  526,
   61,  425,  256,   61,   59,  462,  384,  391,  392,  419,
  434,  999,  312,  313,  462,  419,  396,  317,   59,  396,
  462,  445,   61,  462,  462,  409,  410,  396,  434,  384,
  396,  331,  387,  388,  462,  396,  420,  396,  338,  462,
  418,  462,   61,  462,  468,  429,  462,   59,   61,  462,
  462,  462,   61,   61,  432,   59,   61,  357,   61,   61,
  396,  485,  468,  462,  442,  319,  320,  321,  322,  323,
  324,  325,  326,  419,  419,  462,  431,   61,  433,  485,
  504,  505,  396,  462,  419,  385,  386,  511,  512,  513,
  514,  419,  462,  448,  394,  419,  419,  462,  504,  505,
  396,  396,  989,  527,  462,  511,  512,  513,  514,  462,
  997,  998,  462,  413,  368,  256,  419,  396,  396,  396,
  419,  527,  422,  423,  462,  396,  396,  396,  462,  419,
  462,  509,  462,  517,  518,  256,  520,  521,  522,  494,
  396,  262,  263,  264,  419,  396,  267,  525,   59,  403,
  462,  462,  462,  274,  462,  455,  456,  462,  419,   61,
  462,  302,  283,  284,  285,  286,  396,  288,  396,  462,
  525,  526,  293,  294,   59,   61,  462,  318,   61,  300,
  462,  462,  462,  304,   61,  306,  307,   61,  309,  462,
  462,   61,   61,   61,  315,   61,  462,   61,  419,  340,
   61,  342,   61,  344,  345,   61,   61,   61,   61,   61,
   61,   61,   61,  334,  335,  515,   61,   61,  339,   61,
   59,   61,  419,  364,   61,  346,   61,  462,  419,  350,
  351,  352,  486,  419,  355,  419,  419,  358,  359,  419,
  256,  257,  256,   59,  260,  259,   59,  419,  369,  265,
  419,   59,   61,  419,  375,  376,   61,  378,  379,  380,
  381,  419,  419,   61,  280,  281,  462,  281,  282,  523,
  419,  287,  393,  256,  462,  291,   59,  462,  396,  419,
  462,  402,   59,  404,  405,  299,  419,  408,  462,   59,
  411,  412,  462,   61,  415,   61,  312,  419,  312,   59,
  316,  317,   61,  317,   59,  426,   59,   59,  419,  419,
  419,   59,   59,  419,  419,  329,  419,   59,   59,  302,
   59,   59,  336,   59,   59,  446,  447,  341,  449,  343,
   59,  347,  453,  349,   59,  318,  457,  458,  459,  460,
  461,   59,  356,   59,  465,  466,   59,  363,   59,   59,
   59,   59,   59,  474,   59,   59,   59,  340,   59,  342,
   59,  344,  345,   61,  259,   61,   61,  419,  384,   61,
  384,   61,  259,   61,   61,   61,  390,   61,   61,   61,
   61,  364,   61,   61,   61,   61,  507,  508,   61,  510,
   61,   61,  406,  256,   61,  516,   61,   61,  519,  413,
   61,   61,  418,  524,  299,  268,   61,   61,  529,   61,
   61,  425,  299,  427,  428,   61,  432,  312,  432,   61,
   61,  419,   59,  419,  419,  312,  442,   59,   59,  292,
   59,  419,  295,  296,  329,   61,   61,  419,  301,   59,
  303,  336,  329,   59,   59,   59,  341,   59,  343,  336,
   59,   59,   59,   59,  341,   59,  343,   59,   59,   59,
   59,  356,   59,   59,   59,   59,   59,   59,   59,  356,
   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
   59,   59,  496,   59,   59,   59,   59,   59,  502,   59,
   59,   59,   59,  509,   59,  390,   59,  360,  361,  256,
  514,  515,   59,  390,   59,   59,   59,  370,  371,  525,
   59,  406,  407,  527,   59,   59,   59,   59,  275,  406,
  407,   59,   59,   59,  281,  282,   59,   59,  391,  392,
  425,   59,  427,  428,   59,   59,   59,   59,  425,   59,
  427,  428,  462,   61,  419,   59,  409,  410,  419,  462,
  462,   61,  419,  462,  419,  312,  313,  420,  462,  462,
  317,  462,  256,  256,  462,  259,  429,  396,  462,  462,
  462,  419,  419,  419,  331,   59,  419,  396,  419,   61,
   59,  338,  396,  277,   61,  278,  279,  281,  419,  419,
   59,  419,   59,   59,   59,  289,   59,  290,   59,   59,
  357,  496,   59,  297,   59,   59,  275,  276,   59,  496,
   59,  305,   59,   59,   59,   59,   59,   59,   59,  514,
  314,   59,   59,   59,  419,  419,   61,  514,  385,  386,
   61,   61,  527,  327,  328,   61,  330,  394,   61,   61,
  527,   61,   61,  337,  313,   61,   61,   61,   61,   61,
   61,   61,  275,  276,  517,  518,  413,  520,  521,  522,
  354,   61,  331,   61,   61,  422,  423,   61,   61,  338,
   61,  365,   61,  367,  419,   59,   59,   59,   59,  372,
  373,  374,   59,   59,  377,   59,   59,   59,  357,  383,
  313,  384,   59,   59,   59,   59,   59,   59,  455,  456,
   59,   59,   59,   59,  419,  398,  399,  401,  331,   61,
   59,   61,   59,  419,   59,  338,  385,  386,  462,  419,
   61,  396,  396,  416,  417,  394,   59,   59,  396,  462,
  396,  462,  462,  396,  357,  462,   59,  396,  396,  419,
  434,   59,   59,  396,   59,   59,   59,  419,  441,  443,
  444,   59,   59,   59,   59,   59,  450,  451,  515,   59,
   59,   59,  385,  386,   59,   59,  435,  424,   59,  419,
  419,  394,  469,  470,  471,  472,  473,   59,  475,  476,
  419,  478,  479,  480,  481,  482,  419,  456,  485,  419,
  395,  419,  419,   59,   59,  419,   59,  419,  495,  496,
  497,  498,  499,  500,   59,   59,  503,   59,  419,  506,
   59,   59,  435,  469,  470,  471,  472,  473,   59,  475,
  476,   59,  478,  479,  480,  481,  482,   59,   59,  485,
   59,  467,   44,  456,  424,   61,   61,   59,   59,  495,
  496,  497,  498,  499,  500,  462,   59,  503,  419,  462,
  506,  469,  470,  471,  472,  473,   59,  475,  476,  419,
  478,  479,  480,  481,  482,   59,   59,  485,  419,  419,
   59,   59,   59,   59,   59,   59,   59,  495,  496,  497,
  498,  499,  500,   59,  419,  503,   59,   59,  506,  419,
   59,   59,   59,   59,   59,   59,  462,   59,  462,   59,
  462,  462,   59,  462,  462,   59,  462,   59,   59,   59,
  462,   59,  395,   59,  462,  462,  462,   59,   59,   59,
   59,  462,  462,  462,   59,   59,   59,   59,  396,   59,
   59,   59,   59,   59,   59,   59,  395,   59,   59,   59,
   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
   59,   59,   59,  123,   59,   59,   59,  396,  302,  339,
  123,  285,  123,  892, 1585, 1473, 1565,   73, 1563, 1366,
  547, 1489,  663, 1543, 1471,  578,  610,  698,  618,  513,
 1545, 1548, 1546, 1487,  388,  134, 1464,  203,  409,  486,
 1315, 1317, 1468, 1470,   -1,   -1,  318,   -1,  100,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  537,
};
#define YYFINAL 1
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 529
#if YYDEBUG
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,"','",0,0,0,0,0,0,0,0,0,0,0,0,0,0,"';'",0,"'='",0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'",0,"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
"ACCEPT_PASSWORD","ACTION","ADMIN","AFTYPE","T_ALLOW","ANTI_NICK_FLOOD",
"ANTI_SPAM_EXIT_MESSAGE_TIME","ANTI_SPAM_CONNECT_NUMERIC","AUTOCONN","T_BLOCK",
"BURST_AWAY","BURST_TOPICWHO","BYTES","KBYTES","MBYTES","GBYTES","TBYTES",
"CALLER_ID_WAIT","CAN_FLOOD","CAN_IDLE","CHANNEL","CIDR_BITLEN_IPV4",
"CIDR_BITLEN_IPV6","CIPHER_PREFERENCE","CLASS","CLIENTCERT_HASH","CLOAK_KEY1",
"CLOAK_KEY2","CLOAK_KEY3","CLOAK_WHOIS_ACTUALLY","COMPRESSED",
"COMPRESSION_LEVEL","CONNECT","CONNECTFREQ","CRYPTLINK","CYCLE_ON_HOSTCHANGE",
"DEFAULT_CIPHER_PREFERENCE","DEFAULT_FLOODCOUNT","DEFAULT_SPLIT_SERVER_COUNT",
"DEFAULT_SPLIT_USER_COUNT","DENY","DESCRIPTION","DIE","DISABLE_AUTH",
"DISABLE_FAKE_CHANNELS","DISABLE_HIDDEN","DISABLE_LOCAL_CHANNELS",
"DISABLE_REMOTE_COMMANDS","DNSBL","DOT_IN_IP6_ADDR","DOTS_IN_IDENT","DURATION",
"EGDPOOL_PATH","EMAIL","ENABLE","ENCRYPTED","EXCEED_LIMIT","EXEMPT",
"FAILED_OPER_NOTICE","FAKENAME","IRCD_FLAGS","FLATTEN_LINKS","FFAILED_OPERLOG",
"FKILLLOG","FKLINELOG","FGLINELOG","FIOERRLOG","FOPERLOG","FOPERSPYLOG",
"FUSERLOG","GECOS","GENERAL","GLINE","GLINES","GLINE_EXEMPT","GLINE_LOG",
"GLINE_TIME","GLINE_MIN_CIDR","GLINE_MIN_CIDR6","GLOBAL_KILL","IRCD_AUTH",
"NEED_IDENT","HAVENT_READ_CONF","HIDDEN","HIDDEN_ADMIN","HIDDEN_NAME",
"HIDDEN_OPER","HIDE_SERVER_IPS","HIDE_SERVERS","HIDE_SPOOF_IPS","HOST","HUB",
"HUB_MASK","IDLETIME","IGNORE_BOGUS_TS","INVISIBLE_ON_CONNECT","IP","KILL",
"KILL_CHASE_TIME_LIMIT","KLINE","KLINE_EXEMPT","KLINE_REASON",
"KLINE_WITH_REASON","KNOCK_DELAY","KNOCK_DELAY_CHANNEL","LAZYLINK","LEAF_MASK",
"LINKS_DELAY","LISTEN","T_LOG","LOGGING","LOG_LEVEL","MAX_ACCEPT","MAX_BANS",
"MAX_CHANS_PER_USER","MAX_GLOBAL","MAX_IDENT","MAX_LOCAL","MAX_NICK_CHANGES",
"MAX_NICK_TIME","MAX_NUMBER","MAX_TARGETS","MESSAGE_LOCALE","MIN_NONWILDCARD",
"MIN_NONWILDCARD_SIMPLE","MODULE","MODULES","NAME","NEED_PASSWORD","IS_WEBIRC",
"NETWORK_DESC","NETWORK_NAME","NICK","NICK_CHANGES","NO_CREATE_ON_SPLIT",
"NO_JOIN_ON_SPLIT","NO_OPER_FLOOD","NO_TILDE","NOT","NUMBER","NUMBER_PER_IDENT",
"NUMBER_PER_CIDR","NUMBER_PER_IP","NUMBER_PER_IP_GLOBAL","OPERATOR",
"OPERS_BYPASS_CALLERID","OPER_LOG","OPER_ONLY_UMODES","OPER_PASS_RESV",
"OPER_SPY_T","OPER_FARCONNECT","OPER_UMODES","JOIN_FLOOD_COUNT",
"JOIN_FLOOD_TIME","PACE_WAIT","PACE_WAIT_SIMPLE","PASSWORD","PATH",
"PING_COOKIE","PING_TIME","PING_WARNING","PORT","QSTRING","QUIET_ON_BAN",
"REASON","REDIRPORT","REDIRSERV","REGEX_T","REHASH","TREJECT_HOLD_TIME",
"REMOTE","REMOTEBAN","RESTRICT_CHANNELS","RESTRICTED","RSA_PRIVATE_KEY_FILE",
"RSA_PUBLIC_KEY_FILE","SSL_CERTIFICATE_FILE","RESV","RESV_EXEMPT","SECONDS",
"MINUTES","HOURS","DAYS","WEEKS","SENDQ","SEND_PASSWORD","SERVERHIDE",
"SERVERINFO","SERVICES","SERVICES_NAME","SERVLINK_PATH","IRCD_SID",
"TKLINE_EXPIRE_NOTICES","T_SHARED","T_CLUSTER","TYPE","SHORT_MOTD","SILENT",
"SPOOF","SPOOF_NOTICE","STATS_E_DISABLED","STATS_I_OPER_ONLY",
"STATS_K_OPER_ONLY","STATS_O_OPER_ONLY","STATS_P_OPER_ONLY","TBOOL","TMASKED",
"T_REJECT","TS_MAX_DELTA","TS_WARN_DELTA","TWODOTS","T_ALL","T_BOTS",
"T_SOFTCALLERID","T_CALLERID","T_CCONN","T_NOCTCP","T_CLIENT_FLOOD","T_DEAF",
"T_DEBUG","T_DRONE","T_EXTERNAL","T_FULL","T_HIDECHANNELS","T_FARCONNECT",
"T_INVISIBLE","T_IPV4","T_IPV6","T_LOCOPS","T_LOGPATH","T_L_CRIT","T_L_DEBUG",
"T_L_ERROR","T_L_INFO","T_L_NOTICE","T_L_TRACE","T_L_WARN","T_MAX_CLIENTS",
"T_NCHANGE","T_OPERWALL","T_REJ","T_SERVNOTICE","T_SKILL","T_SPY","T_SSL",
"T_UMODES","T_UNAUTH","T_UNRESV","T_UNXLINE","T_WALLOP","THROTTLE_TIME",
"THROTTLE_NUM","TOPICBURST","TRUE_NO_OPER_FLOOD","TKLINE","TXLINE","TRESV",
"UNKLINE","USER","USE_EGD","USE_EXCEPT","USE_INVEX","HIDE_KILLER",
"USE_REGEX_BANS","USE_KNOCK","USE_NOCTCP","USE_LOGGING","USE_WHOIS_ACTUALLY",
"VHOST","VHOST6","XLINE","WARN","WARN_NO_NLINE",
};
char *yyrule[] = {
"$accept : conf",
"conf :",
"conf : conf conf_item",
"conf_item : admin_entry",
"conf_item : logging_entry",
"conf_item : oper_entry",
"conf_item : channel_entry",
"conf_item : class_entry",
"conf_item : listen_entry",
"conf_item : auth_entry",
"conf_item : serverinfo_entry",
"conf_item : serverhide_entry",
"conf_item : resv_entry",
"conf_item : shared_entry",
"conf_item : cluster_entry",
"conf_item : connect_entry",
"conf_item : kill_entry",
"conf_item : deny_entry",
"conf_item : exempt_entry",
"conf_item : general_entry",
"conf_item : gline_entry",
"conf_item : gecos_entry",
"conf_item : modules_entry",
"conf_item : dnsbl_entry",
"conf_item : error ';'",
"conf_item : error '}'",
"timespec_ :",
"timespec_ : timespec",
"timespec : NUMBER timespec_",
"timespec : NUMBER SECONDS timespec_",
"timespec : NUMBER MINUTES timespec_",
"timespec : NUMBER HOURS timespec_",
"timespec : NUMBER DAYS timespec_",
"timespec : NUMBER WEEKS timespec_",
"sizespec_ :",
"sizespec_ : sizespec",
"sizespec : NUMBER sizespec_",
"sizespec : NUMBER BYTES sizespec_",
"sizespec : NUMBER KBYTES sizespec_",
"sizespec : NUMBER MBYTES sizespec_",
"modules_entry : MODULES '{' modules_items '}' ';'",
"modules_items : modules_items modules_item",
"modules_items : modules_item",
"modules_item : modules_module",
"modules_item : modules_path",
"modules_item : error ';'",
"modules_module : MODULE '=' QSTRING ';'",
"modules_path : PATH '=' QSTRING ';'",
"$$1 :",
"dnsbl_entry : DNSBL $$1 '{' dnsbl_items '}' ';'",
"dnsbl_items : dnsbl_items dnsbl_item",
"dnsbl_items : dnsbl_item",
"dnsbl_item : dnsbl_name",
"dnsbl_item : dnsbl_duration",
"dnsbl_item : dnsbl_reason",
"dnsbl_item : error ';'",
"dnsbl_name : NAME '=' QSTRING ';'",
"dnsbl_duration : DURATION '=' timespec ';'",
"dnsbl_reason : REASON '=' QSTRING ';'",
"serverinfo_entry : SERVERINFO '{' serverinfo_items '}' ';'",
"serverinfo_items : serverinfo_items serverinfo_item",
"serverinfo_items : serverinfo_item",
"serverinfo_item : serverinfo_name",
"serverinfo_item : serverinfo_vhost",
"serverinfo_item : serverinfo_hub",
"serverinfo_item : serverinfo_description",
"serverinfo_item : serverinfo_network_name",
"serverinfo_item : serverinfo_network_desc",
"serverinfo_item : serverinfo_max_clients",
"serverinfo_item : serverinfo_rsa_private_key_file",
"serverinfo_item : serverinfo_vhost6",
"serverinfo_item : serverinfo_sid",
"serverinfo_item : serverinfo_ssl_certificate_file",
"serverinfo_item : error ';'",
"serverinfo_ssl_certificate_file : SSL_CERTIFICATE_FILE '=' QSTRING ';'",
"serverinfo_rsa_private_key_file : RSA_PRIVATE_KEY_FILE '=' QSTRING ';'",
"serverinfo_name : NAME '=' QSTRING ';'",
"serverinfo_sid : IRCD_SID '=' QSTRING ';'",
"serverinfo_description : DESCRIPTION '=' QSTRING ';'",
"serverinfo_network_name : NETWORK_NAME '=' QSTRING ';'",
"serverinfo_network_desc : NETWORK_DESC '=' QSTRING ';'",
"serverinfo_vhost : VHOST '=' QSTRING ';'",
"serverinfo_vhost6 : VHOST6 '=' QSTRING ';'",
"serverinfo_max_clients : T_MAX_CLIENTS '=' NUMBER ';'",
"serverinfo_hub : HUB '=' TBOOL ';'",
"admin_entry : ADMIN '{' admin_items '}' ';'",
"admin_items : admin_items admin_item",
"admin_items : admin_item",
"admin_item : admin_name",
"admin_item : admin_description",
"admin_item : admin_email",
"admin_item : error ';'",
"admin_name : NAME '=' QSTRING ';'",
"admin_email : EMAIL '=' QSTRING ';'",
"admin_description : DESCRIPTION '=' QSTRING ';'",
"logging_entry : LOGGING '{' logging_items '}' ';'",
"logging_items : logging_items logging_item",
"logging_items : logging_item",
"logging_item : logging_path",
"logging_item : logging_oper_log",
"logging_item : logging_log_level",
"logging_item : logging_use_logging",
"logging_item : logging_fuserlog",
"logging_item : logging_foperlog",
"logging_item : logging_fglinelog",
"logging_item : logging_fklinelog",
"logging_item : logging_killlog",
"logging_item : logging_foperspylog",
"logging_item : logging_ioerrlog",
"logging_item : logging_ffailed_operlog",
"logging_item : error ';'",
"logging_path : T_LOGPATH '=' QSTRING ';'",
"logging_oper_log : OPER_LOG '=' QSTRING ';'",
"logging_fuserlog : FUSERLOG '=' QSTRING ';'",
"logging_ffailed_operlog : FFAILED_OPERLOG '=' QSTRING ';'",
"logging_foperlog : FOPERLOG '=' QSTRING ';'",
"logging_foperspylog : FOPERSPYLOG '=' QSTRING ';'",
"logging_fglinelog : FGLINELOG '=' QSTRING ';'",
"logging_fklinelog : FKLINELOG '=' QSTRING ';'",
"logging_ioerrlog : FIOERRLOG '=' QSTRING ';'",
"logging_killlog : FKILLLOG '=' QSTRING ';'",
"logging_log_level : LOG_LEVEL '=' T_L_CRIT ';'",
"logging_log_level : LOG_LEVEL '=' T_L_ERROR ';'",
"logging_log_level : LOG_LEVEL '=' T_L_WARN ';'",
"logging_log_level : LOG_LEVEL '=' T_L_NOTICE ';'",
"logging_log_level : LOG_LEVEL '=' T_L_TRACE ';'",
"logging_log_level : LOG_LEVEL '=' T_L_INFO ';'",
"logging_log_level : LOG_LEVEL '=' T_L_DEBUG ';'",
"logging_use_logging : USE_LOGGING '=' TBOOL ';'",
"$$2 :",
"oper_entry : OPERATOR $$2 oper_name_b '{' oper_items '}' ';'",
"oper_name_b :",
"oper_name_b : oper_name_t",
"oper_items : oper_items oper_item",
"oper_items : oper_item",
"oper_item : oper_name",
"oper_item : oper_user",
"oper_item : oper_password",
"oper_item : oper_hidden_admin",
"oper_item : oper_hidden_oper",
"oper_item : oper_umodes",
"oper_item : oper_class",
"oper_item : oper_global_kill",
"oper_item : oper_remote",
"oper_item : oper_kline",
"oper_item : oper_xline",
"oper_item : oper_unkline",
"oper_item : oper_gline",
"oper_item : oper_nick_changes",
"oper_item : oper_remoteban",
"oper_item : oper_die",
"oper_item : oper_rehash",
"oper_item : oper_admin",
"oper_item : oper_operwall",
"oper_item : oper_encrypted",
"oper_item : oper_rsa_public_key_file",
"oper_item : oper_client_certificate_hash",
"oper_item : oper_spy",
"oper_item : oper_flags",
"oper_item : error ';'",
"oper_name : NAME '=' QSTRING ';'",
"oper_name_t : QSTRING",
"oper_user : USER '=' QSTRING ';'",
"oper_client_certificate_hash : CLIENTCERT_HASH '=' QSTRING ';'",
"oper_password : PASSWORD '=' QSTRING ';'",
"oper_encrypted : ENCRYPTED '=' TBOOL ';'",
"oper_rsa_public_key_file : RSA_PUBLIC_KEY_FILE '=' QSTRING ';'",
"oper_class : CLASS '=' QSTRING ';'",
"$$3 :",
"oper_umodes : T_UMODES $$3 '=' oper_umodes_items ';'",
"oper_umodes_items : oper_umodes_items ',' oper_umodes_item",
"oper_umodes_items : oper_umodes_item",
"oper_umodes_item : T_BOTS",
"oper_umodes_item : T_CCONN",
"oper_umodes_item : T_NOCTCP",
"oper_umodes_item : T_DEAF",
"oper_umodes_item : T_DEBUG",
"oper_umodes_item : T_FULL",
"oper_umodes_item : T_SKILL",
"oper_umodes_item : T_NCHANGE",
"oper_umodes_item : T_REJ",
"oper_umodes_item : T_UNAUTH",
"oper_umodes_item : T_SPY",
"oper_umodes_item : T_EXTERNAL",
"oper_umodes_item : T_OPERWALL",
"oper_umodes_item : T_SERVNOTICE",
"oper_umodes_item : T_INVISIBLE",
"oper_umodes_item : T_WALLOP",
"oper_umodes_item : T_SOFTCALLERID",
"oper_umodes_item : T_CALLERID",
"oper_umodes_item : T_LOCOPS",
"oper_umodes_item : T_HIDECHANNELS",
"oper_umodes_item : T_FARCONNECT",
"oper_global_kill : GLOBAL_KILL '=' TBOOL ';'",
"oper_remote : REMOTE '=' TBOOL ';'",
"oper_remoteban : REMOTEBAN '=' TBOOL ';'",
"oper_kline : KLINE '=' TBOOL ';'",
"oper_xline : XLINE '=' TBOOL ';'",
"oper_unkline : UNKLINE '=' TBOOL ';'",
"oper_gline : GLINE '=' TBOOL ';'",
"oper_nick_changes : NICK_CHANGES '=' TBOOL ';'",
"oper_die : DIE '=' TBOOL ';'",
"oper_rehash : REHASH '=' TBOOL ';'",
"oper_admin : ADMIN '=' TBOOL ';'",
"oper_hidden_admin : HIDDEN_ADMIN '=' TBOOL ';'",
"oper_hidden_oper : HIDDEN_OPER '=' TBOOL ';'",
"oper_spy : OPER_SPY_T '=' TBOOL ';'",
"oper_operwall : T_OPERWALL '=' TBOOL ';'",
"$$4 :",
"oper_flags : IRCD_FLAGS $$4 '=' oper_flags_items ';'",
"oper_flags_items : oper_flags_items ',' oper_flags_item",
"oper_flags_items : oper_flags_item",
"$$5 :",
"oper_flags_item : NOT $$5 oper_flags_item_atom",
"$$6 :",
"oper_flags_item : $$6 oper_flags_item_atom",
"oper_flags_item_atom : GLOBAL_KILL",
"oper_flags_item_atom : REMOTE",
"oper_flags_item_atom : KLINE",
"oper_flags_item_atom : UNKLINE",
"oper_flags_item_atom : XLINE",
"oper_flags_item_atom : GLINE",
"oper_flags_item_atom : DIE",
"oper_flags_item_atom : REHASH",
"oper_flags_item_atom : ADMIN",
"oper_flags_item_atom : HIDDEN_ADMIN",
"oper_flags_item_atom : NICK_CHANGES",
"oper_flags_item_atom : T_OPERWALL",
"oper_flags_item_atom : OPER_SPY_T",
"oper_flags_item_atom : HIDDEN_OPER",
"oper_flags_item_atom : REMOTEBAN",
"oper_flags_item_atom : ENCRYPTED",
"oper_flags_item_atom : OPER_FARCONNECT",
"$$7 :",
"class_entry : CLASS $$7 class_name_b '{' class_items '}' ';'",
"class_name_b :",
"class_name_b : class_name_t",
"class_items : class_items class_item",
"class_items : class_item",
"class_item : class_name",
"class_item : class_cidr_bitlen_ipv4",
"class_item : class_cidr_bitlen_ipv6",
"class_item : class_ping_time",
"class_item : class_ping_warning",
"class_item : class_number_per_cidr",
"class_item : class_number_per_ip",
"class_item : class_connectfreq",
"class_item : class_max_number",
"class_item : class_max_global",
"class_item : class_max_local",
"class_item : class_max_ident",
"class_item : class_sendq",
"class_item : error ';'",
"class_name : NAME '=' QSTRING ';'",
"class_name_t : QSTRING",
"class_ping_time : PING_TIME '=' timespec ';'",
"class_ping_warning : PING_WARNING '=' timespec ';'",
"class_number_per_ip : NUMBER_PER_IP '=' NUMBER ';'",
"class_connectfreq : CONNECTFREQ '=' timespec ';'",
"class_max_number : MAX_NUMBER '=' NUMBER ';'",
"class_max_global : MAX_GLOBAL '=' NUMBER ';'",
"class_max_local : MAX_LOCAL '=' NUMBER ';'",
"class_max_ident : MAX_IDENT '=' NUMBER ';'",
"class_sendq : SENDQ '=' sizespec ';'",
"class_cidr_bitlen_ipv4 : CIDR_BITLEN_IPV4 '=' NUMBER ';'",
"class_cidr_bitlen_ipv6 : CIDR_BITLEN_IPV6 '=' NUMBER ';'",
"class_number_per_cidr : NUMBER_PER_CIDR '=' NUMBER ';'",
"$$8 :",
"listen_entry : LISTEN $$8 '{' listen_items '}' ';'",
"$$9 :",
"listen_flags : IRCD_FLAGS $$9 '=' listen_flags_items ';'",
"listen_flags_items : listen_flags_items ',' listen_flags_item",
"listen_flags_items : listen_flags_item",
"listen_flags_item : T_SSL",
"listen_flags_item : HIDDEN",
"listen_items : listen_items listen_item",
"listen_items : listen_item",
"listen_item : listen_port",
"listen_item : listen_flags",
"listen_item : listen_address",
"listen_item : listen_host",
"listen_item : error ';'",
"$$10 :",
"listen_port : PORT '=' port_items $$10 ';'",
"port_items : port_items ',' port_item",
"port_items : port_item",
"port_item : NUMBER",
"port_item : NUMBER TWODOTS NUMBER",
"listen_address : IP '=' QSTRING ';'",
"listen_host : HOST '=' QSTRING ';'",
"$$11 :",
"auth_entry : IRCD_AUTH $$11 '{' auth_items '}' ';'",
"auth_items : auth_items auth_item",
"auth_items : auth_item",
"auth_item : auth_user",
"auth_item : auth_passwd",
"auth_item : auth_class",
"auth_item : auth_flags",
"auth_item : auth_kline_exempt",
"auth_item : auth_need_ident",
"auth_item : auth_exceed_limit",
"auth_item : auth_no_tilde",
"auth_item : auth_gline_exempt",
"auth_item : auth_spoof",
"auth_item : auth_spoof_notice",
"auth_item : auth_webirc",
"auth_item : auth_redir_serv",
"auth_item : auth_redir_port",
"auth_item : auth_can_flood",
"auth_item : auth_need_password",
"auth_item : auth_encrypted",
"auth_item : auth_client_certificate_hash",
"auth_item : error ';'",
"auth_user : USER '=' QSTRING ';'",
"auth_passwd : PASSWORD '=' QSTRING ';'",
"auth_client_certificate_hash : CLIENTCERT_HASH '=' QSTRING ';'",
"auth_spoof_notice : SPOOF_NOTICE '=' TBOOL ';'",
"auth_class : CLASS '=' QSTRING ';'",
"auth_encrypted : ENCRYPTED '=' TBOOL ';'",
"$$12 :",
"auth_flags : IRCD_FLAGS $$12 '=' auth_flags_items ';'",
"auth_flags_items : auth_flags_items ',' auth_flags_item",
"auth_flags_items : auth_flags_item",
"$$13 :",
"auth_flags_item : NOT $$13 auth_flags_item_atom",
"$$14 :",
"auth_flags_item : $$14 auth_flags_item_atom",
"auth_flags_item_atom : SPOOF_NOTICE",
"auth_flags_item_atom : EXCEED_LIMIT",
"auth_flags_item_atom : KLINE_EXEMPT",
"auth_flags_item_atom : NEED_IDENT",
"auth_flags_item_atom : CAN_FLOOD",
"auth_flags_item_atom : CAN_IDLE",
"auth_flags_item_atom : NO_TILDE",
"auth_flags_item_atom : GLINE_EXEMPT",
"auth_flags_item_atom : RESV_EXEMPT",
"auth_flags_item_atom : IS_WEBIRC",
"auth_flags_item_atom : NEED_PASSWORD",
"auth_kline_exempt : KLINE_EXEMPT '=' TBOOL ';'",
"auth_need_ident : NEED_IDENT '=' TBOOL ';'",
"auth_exceed_limit : EXCEED_LIMIT '=' TBOOL ';'",
"auth_can_flood : CAN_FLOOD '=' TBOOL ';'",
"auth_no_tilde : NO_TILDE '=' TBOOL ';'",
"auth_gline_exempt : GLINE_EXEMPT '=' TBOOL ';'",
"auth_spoof : SPOOF '=' QSTRING ';'",
"auth_redir_serv : REDIRSERV '=' QSTRING ';'",
"auth_redir_port : REDIRPORT '=' NUMBER ';'",
"auth_webirc : IS_WEBIRC '=' TBOOL ';'",
"auth_need_password : NEED_PASSWORD '=' TBOOL ';'",
"$$15 :",
"resv_entry : RESV $$15 '{' resv_items '}' ';'",
"resv_items : resv_items resv_item",
"resv_items : resv_item",
"resv_item : resv_creason",
"resv_item : resv_channel",
"resv_item : resv_nick",
"resv_item : error ';'",
"resv_creason : REASON '=' QSTRING ';'",
"resv_channel : CHANNEL '=' QSTRING ';'",
"resv_nick : NICK '=' QSTRING ';'",
"$$16 :",
"shared_entry : T_SHARED $$16 '{' shared_items '}' ';'",
"shared_items : shared_items shared_item",
"shared_items : shared_item",
"shared_item : shared_name",
"shared_item : shared_user",
"shared_item : shared_type",
"shared_item : error ';'",
"shared_name : NAME '=' QSTRING ';'",
"shared_user : USER '=' QSTRING ';'",
"$$17 :",
"shared_type : TYPE $$17 '=' shared_types ';'",
"shared_types : shared_types ',' shared_type_item",
"shared_types : shared_type_item",
"shared_type_item : KLINE",
"shared_type_item : TKLINE",
"shared_type_item : UNKLINE",
"shared_type_item : XLINE",
"shared_type_item : TXLINE",
"shared_type_item : T_UNXLINE",
"shared_type_item : RESV",
"shared_type_item : TRESV",
"shared_type_item : T_UNRESV",
"shared_type_item : T_LOCOPS",
"shared_type_item : SERVICES",
"shared_type_item : REHASH",
"shared_type_item : T_ALL",
"$$18 :",
"cluster_entry : T_CLUSTER $$18 '{' cluster_items '}' ';'",
"cluster_items : cluster_items cluster_item",
"cluster_items : cluster_item",
"cluster_item : cluster_name",
"cluster_item : cluster_type",
"cluster_item : error ';'",
"cluster_name : NAME '=' QSTRING ';'",
"$$19 :",
"cluster_type : TYPE $$19 '=' cluster_types ';'",
"cluster_types : cluster_types ',' cluster_type_item",
"cluster_types : cluster_type_item",
"cluster_type_item : KLINE",
"cluster_type_item : TKLINE",
"cluster_type_item : UNKLINE",
"cluster_type_item : XLINE",
"cluster_type_item : TXLINE",
"cluster_type_item : T_UNXLINE",
"cluster_type_item : RESV",
"cluster_type_item : TRESV",
"cluster_type_item : T_UNRESV",
"cluster_type_item : T_LOCOPS",
"cluster_type_item : T_ALL",
"$$20 :",
"connect_entry : CONNECT $$20 connect_name_b '{' connect_items '}' ';'",
"connect_name_b :",
"connect_name_b : connect_name_t",
"connect_items : connect_items connect_item",
"connect_items : connect_item",
"connect_item : connect_name",
"connect_item : connect_host",
"connect_item : connect_vhost",
"connect_item : connect_send_password",
"connect_item : connect_accept_password",
"connect_item : connect_aftype",
"connect_item : connect_port",
"connect_item : connect_fakename",
"connect_item : connect_flags",
"connect_item : connect_hub_mask",
"connect_item : connect_leaf_mask",
"connect_item : connect_class",
"connect_item : connect_auto",
"connect_item : connect_encrypted",
"connect_item : connect_compressed",
"connect_item : connect_cryptlink",
"connect_item : connect_rsa_public_key_file",
"connect_item : connect_cipher_preference",
"connect_item : connect_topicburst",
"connect_item : error ';'",
"connect_name : NAME '=' QSTRING ';'",
"connect_name_t : QSTRING",
"connect_host : HOST '=' QSTRING ';'",
"connect_vhost : VHOST '=' QSTRING ';'",
"connect_send_password : SEND_PASSWORD '=' QSTRING ';'",
"connect_accept_password : ACCEPT_PASSWORD '=' QSTRING ';'",
"connect_port : PORT '=' NUMBER ';'",
"connect_aftype : AFTYPE '=' T_IPV4 ';'",
"connect_aftype : AFTYPE '=' T_IPV6 ';'",
"connect_fakename : FAKENAME '=' QSTRING ';'",
"$$21 :",
"connect_flags : IRCD_FLAGS $$21 '=' connect_flags_items ';'",
"connect_flags_items : connect_flags_items ',' connect_flags_item",
"connect_flags_items : connect_flags_item",
"$$22 :",
"connect_flags_item : NOT $$22 connect_flags_item_atom",
"$$23 :",
"connect_flags_item : $$23 connect_flags_item_atom",
"connect_flags_item_atom : LAZYLINK",
"connect_flags_item_atom : COMPRESSED",
"connect_flags_item_atom : CRYPTLINK",
"connect_flags_item_atom : AUTOCONN",
"connect_flags_item_atom : BURST_AWAY",
"connect_flags_item_atom : TOPICBURST",
"connect_rsa_public_key_file : RSA_PUBLIC_KEY_FILE '=' QSTRING ';'",
"connect_encrypted : ENCRYPTED '=' TBOOL ';'",
"connect_cryptlink : CRYPTLINK '=' TBOOL ';'",
"connect_compressed : COMPRESSED '=' TBOOL ';'",
"connect_auto : AUTOCONN '=' TBOOL ';'",
"connect_topicburst : TOPICBURST '=' TBOOL ';'",
"connect_hub_mask : HUB_MASK '=' QSTRING ';'",
"connect_leaf_mask : LEAF_MASK '=' QSTRING ';'",
"connect_class : CLASS '=' QSTRING ';'",
"connect_cipher_preference : CIPHER_PREFERENCE '=' QSTRING ';'",
"$$24 :",
"kill_entry : KILL $$24 '{' kill_items '}' ';'",
"$$25 :",
"kill_type : TYPE $$25 '=' kill_type_items ';'",
"kill_type_items : kill_type_items ',' kill_type_item",
"kill_type_items : kill_type_item",
"kill_type_item : REGEX_T",
"kill_items : kill_items kill_item",
"kill_items : kill_item",
"kill_item : kill_user",
"kill_item : kill_reason",
"kill_item : kill_type",
"kill_item : error",
"kill_user : USER '=' QSTRING ';'",
"kill_reason : REASON '=' QSTRING ';'",
"$$26 :",
"deny_entry : DENY $$26 '{' deny_items '}' ';'",
"deny_items : deny_items deny_item",
"deny_items : deny_item",
"deny_item : deny_ip",
"deny_item : deny_reason",
"deny_item : error",
"deny_ip : IP '=' QSTRING ';'",
"deny_reason : REASON '=' QSTRING ';'",
"exempt_entry : EXEMPT '{' exempt_items '}' ';'",
"exempt_items : exempt_items exempt_item",
"exempt_items : exempt_item",
"exempt_item : exempt_ip",
"exempt_item : exempt_client_certificate_hash",
"exempt_item : error",
"exempt_ip : IP '=' QSTRING ';'",
"exempt_client_certificate_hash : CLIENTCERT_HASH '=' QSTRING ';'",
"$$27 :",
"gecos_entry : GECOS $$27 '{' gecos_items '}' ';'",
"$$28 :",
"gecos_flags : TYPE $$28 '=' gecos_flags_items ';'",
"gecos_flags_items : gecos_flags_items ',' gecos_flags_item",
"gecos_flags_items : gecos_flags_item",
"gecos_flags_item : REGEX_T",
"gecos_items : gecos_items gecos_item",
"gecos_items : gecos_item",
"gecos_item : gecos_name",
"gecos_item : gecos_reason",
"gecos_item : gecos_flags",
"gecos_item : error",
"gecos_name : NAME '=' QSTRING ';'",
"gecos_reason : REASON '=' QSTRING ';'",
"general_entry : GENERAL '{' general_items '}' ';'",
"general_items : general_items general_item",
"general_items : general_item",
"general_item : general_hide_spoof_ips",
"general_item : general_ignore_bogus_ts",
"general_item : general_failed_oper_notice",
"general_item : general_anti_nick_flood",
"general_item : general_max_nick_time",
"general_item : general_max_nick_changes",
"general_item : general_max_accept",
"general_item : general_anti_spam_exit_message_time",
"general_item : general_anti_spam_connect_numeric",
"general_item : general_ts_warn_delta",
"general_item : general_ts_max_delta",
"general_item : general_kill_chase_time_limit",
"general_item : general_kline_with_reason",
"general_item : general_kline_reason",
"general_item : general_invisible_on_connect",
"general_item : general_warn_no_nline",
"general_item : general_dots_in_ident",
"general_item : general_stats_o_oper_only",
"general_item : general_stats_k_oper_only",
"general_item : general_pace_wait",
"general_item : general_stats_i_oper_only",
"general_item : general_pace_wait_simple",
"general_item : general_stats_P_oper_only",
"general_item : general_short_motd",
"general_item : general_no_oper_flood",
"general_item : general_true_no_oper_flood",
"general_item : general_oper_pass_resv",
"general_item : general_idletime",
"general_item : general_message_locale",
"general_item : general_oper_only_umodes",
"general_item : general_max_targets",
"general_item : general_use_egd",
"general_item : general_egdpool_path",
"general_item : general_oper_umodes",
"general_item : general_caller_id_wait",
"general_item : general_opers_bypass_callerid",
"general_item : general_default_floodcount",
"general_item : general_min_nonwildcard",
"general_item : general_min_nonwildcard_simple",
"general_item : general_servlink_path",
"general_item : general_disable_remote_commands",
"general_item : general_default_cipher_preference",
"general_item : general_stats_e_disabled",
"general_item : general_compression_level",
"general_item : general_client_flood",
"general_item : general_throttle_num",
"general_item : general_throttle_time",
"general_item : general_havent_read_conf",
"general_item : general_dot_in_ip6_addr",
"general_item : general_ping_cookie",
"general_item : general_disable_auth",
"general_item : general_burst_away",
"general_item : general_tkline_expire_notices",
"general_item : general_gline_min_cidr",
"general_item : general_gline_min_cidr6",
"general_item : general_use_whois_actually",
"general_item : general_reject_hold_time",
"general_item : general_hide_killer",
"general_item : general_cloak_key1",
"general_item : general_cloak_key2",
"general_item : general_cloak_key3",
"general_item : general_cloak_whois_actually",
"general_item : general_services_name",
"general_item : error",
"general_gline_min_cidr : GLINE_MIN_CIDR '=' NUMBER ';'",
"general_gline_min_cidr6 : GLINE_MIN_CIDR6 '=' NUMBER ';'",
"general_burst_away : BURST_AWAY '=' TBOOL ';'",
"general_use_whois_actually : USE_WHOIS_ACTUALLY '=' TBOOL ';'",
"general_reject_hold_time : TREJECT_HOLD_TIME '=' timespec ';'",
"general_tkline_expire_notices : TKLINE_EXPIRE_NOTICES '=' TBOOL ';'",
"general_kill_chase_time_limit : KILL_CHASE_TIME_LIMIT '=' NUMBER ';'",
"general_hide_spoof_ips : HIDE_SPOOF_IPS '=' TBOOL ';'",
"general_ignore_bogus_ts : IGNORE_BOGUS_TS '=' TBOOL ';'",
"general_disable_remote_commands : DISABLE_REMOTE_COMMANDS '=' TBOOL ';'",
"general_failed_oper_notice : FAILED_OPER_NOTICE '=' TBOOL ';'",
"general_anti_nick_flood : ANTI_NICK_FLOOD '=' TBOOL ';'",
"general_max_nick_time : MAX_NICK_TIME '=' timespec ';'",
"general_max_nick_changes : MAX_NICK_CHANGES '=' NUMBER ';'",
"general_max_accept : MAX_ACCEPT '=' NUMBER ';'",
"general_anti_spam_exit_message_time : ANTI_SPAM_EXIT_MESSAGE_TIME '=' timespec ';'",
"general_anti_spam_connect_numeric : ANTI_SPAM_CONNECT_NUMERIC '=' TBOOL ';'",
"general_ts_warn_delta : TS_WARN_DELTA '=' timespec ';'",
"general_ts_max_delta : TS_MAX_DELTA '=' timespec ';'",
"general_havent_read_conf : HAVENT_READ_CONF '=' NUMBER ';'",
"general_kline_with_reason : KLINE_WITH_REASON '=' TBOOL ';'",
"general_kline_reason : KLINE_REASON '=' QSTRING ';'",
"general_cloak_key1 : CLOAK_KEY1 '=' QSTRING ';'",
"general_cloak_key2 : CLOAK_KEY2 '=' QSTRING ';'",
"general_cloak_key3 : CLOAK_KEY3 '=' QSTRING ';'",
"general_cloak_whois_actually : CLOAK_WHOIS_ACTUALLY '=' TBOOL ';'",
"general_services_name : SERVICES_NAME '=' QSTRING ';'",
"general_invisible_on_connect : INVISIBLE_ON_CONNECT '=' TBOOL ';'",
"general_warn_no_nline : WARN_NO_NLINE '=' TBOOL ';'",
"general_stats_e_disabled : STATS_E_DISABLED '=' TBOOL ';'",
"general_stats_o_oper_only : STATS_O_OPER_ONLY '=' TBOOL ';'",
"general_stats_P_oper_only : STATS_P_OPER_ONLY '=' TBOOL ';'",
"general_hide_killer : HIDE_KILLER '=' TBOOL ';'",
"general_stats_k_oper_only : STATS_K_OPER_ONLY '=' TBOOL ';'",
"general_stats_k_oper_only : STATS_K_OPER_ONLY '=' TMASKED ';'",
"general_stats_i_oper_only : STATS_I_OPER_ONLY '=' TBOOL ';'",
"general_stats_i_oper_only : STATS_I_OPER_ONLY '=' TMASKED ';'",
"general_pace_wait : PACE_WAIT '=' timespec ';'",
"general_caller_id_wait : CALLER_ID_WAIT '=' timespec ';'",
"general_opers_bypass_callerid : OPERS_BYPASS_CALLERID '=' TBOOL ';'",
"general_pace_wait_simple : PACE_WAIT_SIMPLE '=' timespec ';'",
"general_short_motd : SHORT_MOTD '=' TBOOL ';'",
"general_no_oper_flood : NO_OPER_FLOOD '=' TBOOL ';'",
"general_true_no_oper_flood : TRUE_NO_OPER_FLOOD '=' TBOOL ';'",
"general_oper_pass_resv : OPER_PASS_RESV '=' TBOOL ';'",
"general_message_locale : MESSAGE_LOCALE '=' QSTRING ';'",
"general_idletime : IDLETIME '=' timespec ';'",
"general_dots_in_ident : DOTS_IN_IDENT '=' NUMBER ';'",
"general_max_targets : MAX_TARGETS '=' NUMBER ';'",
"general_servlink_path : SERVLINK_PATH '=' QSTRING ';'",
"general_default_cipher_preference : DEFAULT_CIPHER_PREFERENCE '=' QSTRING ';'",
"general_compression_level : COMPRESSION_LEVEL '=' NUMBER ';'",
"general_use_egd : USE_EGD '=' TBOOL ';'",
"general_egdpool_path : EGDPOOL_PATH '=' QSTRING ';'",
"general_ping_cookie : PING_COOKIE '=' TBOOL ';'",
"general_disable_auth : DISABLE_AUTH '=' TBOOL ';'",
"general_throttle_num : THROTTLE_NUM '=' NUMBER ';'",
"general_throttle_time : THROTTLE_TIME '=' timespec ';'",
"$$29 :",
"general_oper_umodes : OPER_UMODES $$29 '=' umode_oitems ';'",
"umode_oitems : umode_oitems ',' umode_oitem",
"umode_oitems : umode_oitem",
"umode_oitem : T_BOTS",
"umode_oitem : T_CCONN",
"umode_oitem : T_NOCTCP",
"umode_oitem : T_DEAF",
"umode_oitem : T_DEBUG",
"umode_oitem : T_FULL",
"umode_oitem : T_SKILL",
"umode_oitem : T_NCHANGE",
"umode_oitem : T_REJ",
"umode_oitem : T_UNAUTH",
"umode_oitem : T_SPY",
"umode_oitem : T_EXTERNAL",
"umode_oitem : T_OPERWALL",
"umode_oitem : T_SERVNOTICE",
"umode_oitem : T_INVISIBLE",
"umode_oitem : T_WALLOP",
"umode_oitem : T_SOFTCALLERID",
"umode_oitem : T_CALLERID",
"umode_oitem : T_LOCOPS",
"umode_oitem : T_HIDECHANNELS",
"umode_oitem : T_FARCONNECT",
"$$30 :",
"general_oper_only_umodes : OPER_ONLY_UMODES $$30 '=' umode_items ';'",
"umode_items : umode_items ',' umode_item",
"umode_items : umode_item",
"umode_item : T_BOTS",
"umode_item : T_CCONN",
"umode_item : T_NOCTCP",
"umode_item : T_DEAF",
"umode_item : T_DEBUG",
"umode_item : T_FULL",
"umode_item : T_SKILL",
"umode_item : T_NCHANGE",
"umode_item : T_REJ",
"umode_item : T_UNAUTH",
"umode_item : T_SPY",
"umode_item : T_EXTERNAL",
"umode_item : T_OPERWALL",
"umode_item : T_SERVNOTICE",
"umode_item : T_INVISIBLE",
"umode_item : T_WALLOP",
"umode_item : T_SOFTCALLERID",
"umode_item : T_CALLERID",
"umode_item : T_LOCOPS",
"umode_item : T_HIDECHANNELS",
"umode_item : T_FARCONNECT",
"general_min_nonwildcard : MIN_NONWILDCARD '=' NUMBER ';'",
"general_min_nonwildcard_simple : MIN_NONWILDCARD_SIMPLE '=' NUMBER ';'",
"general_default_floodcount : DEFAULT_FLOODCOUNT '=' NUMBER ';'",
"general_client_flood : T_CLIENT_FLOOD '=' sizespec ';'",
"general_dot_in_ip6_addr : DOT_IN_IP6_ADDR '=' TBOOL ';'",
"$$31 :",
"gline_entry : GLINES $$31 '{' gline_items '}' ';'",
"gline_items : gline_items gline_item",
"gline_items : gline_item",
"gline_item : gline_enable",
"gline_item : gline_duration",
"gline_item : gline_logging",
"gline_item : gline_user",
"gline_item : gline_server",
"gline_item : gline_action",
"gline_item : error",
"gline_enable : ENABLE '=' TBOOL ';'",
"gline_duration : DURATION '=' timespec ';'",
"$$32 :",
"gline_logging : LOGGING $$32 '=' gline_logging_types ';'",
"gline_logging_types : gline_logging_types ',' gline_logging_type_item",
"gline_logging_types : gline_logging_type_item",
"gline_logging_type_item : T_REJECT",
"gline_logging_type_item : T_BLOCK",
"gline_user : USER '=' QSTRING ';'",
"gline_server : NAME '=' QSTRING ';'",
"$$33 :",
"gline_action : ACTION $$33 '=' gdeny_types ';'",
"gdeny_types : gdeny_types ',' gdeny_type_item",
"gdeny_types : gdeny_type_item",
"gdeny_type_item : T_REJECT",
"gdeny_type_item : T_BLOCK",
"channel_entry : CHANNEL '{' channel_items '}' ';'",
"channel_items : channel_items channel_item",
"channel_items : channel_item",
"channel_item : channel_disable_local_channels",
"channel_item : channel_use_except",
"channel_item : channel_use_invex",
"channel_item : channel_use_knock",
"channel_item : channel_use_noctcp",
"channel_item : channel_use_regex_bans",
"channel_item : channel_max_bans",
"channel_item : channel_knock_delay",
"channel_item : channel_knock_delay_channel",
"channel_item : channel_max_chans_per_user",
"channel_item : channel_quiet_on_ban",
"channel_item : channel_default_split_user_count",
"channel_item : channel_default_split_server_count",
"channel_item : channel_no_create_on_split",
"channel_item : channel_restrict_channels",
"channel_item : channel_no_join_on_split",
"channel_item : channel_burst_topicwho",
"channel_item : channel_jflood_count",
"channel_item : channel_jflood_time",
"channel_item : channel_disable_fake_channels",
"channel_item : channel_cycle_on_hostchange",
"channel_item : error",
"channel_cycle_on_hostchange : CYCLE_ON_HOSTCHANGE '=' TBOOL ';'",
"channel_disable_fake_channels : DISABLE_FAKE_CHANNELS '=' TBOOL ';'",
"channel_restrict_channels : RESTRICT_CHANNELS '=' TBOOL ';'",
"channel_disable_local_channels : DISABLE_LOCAL_CHANNELS '=' TBOOL ';'",
"channel_use_except : USE_EXCEPT '=' TBOOL ';'",
"channel_use_invex : USE_INVEX '=' TBOOL ';'",
"channel_use_regex_bans : USE_REGEX_BANS '=' TBOOL ';'",
"channel_use_knock : USE_KNOCK '=' TBOOL ';'",
"channel_use_noctcp : USE_NOCTCP '=' TBOOL ';'",
"channel_knock_delay : KNOCK_DELAY '=' timespec ';'",
"channel_knock_delay_channel : KNOCK_DELAY_CHANNEL '=' timespec ';'",
"channel_max_chans_per_user : MAX_CHANS_PER_USER '=' NUMBER ';'",
"channel_quiet_on_ban : QUIET_ON_BAN '=' TBOOL ';'",
"channel_max_bans : MAX_BANS '=' NUMBER ';'",
"channel_default_split_user_count : DEFAULT_SPLIT_USER_COUNT '=' NUMBER ';'",
"channel_default_split_server_count : DEFAULT_SPLIT_SERVER_COUNT '=' NUMBER ';'",
"channel_no_create_on_split : NO_CREATE_ON_SPLIT '=' TBOOL ';'",
"channel_no_join_on_split : NO_JOIN_ON_SPLIT '=' TBOOL ';'",
"channel_burst_topicwho : BURST_TOPICWHO '=' TBOOL ';'",
"channel_jflood_count : JOIN_FLOOD_COUNT '=' NUMBER ';'",
"channel_jflood_time : JOIN_FLOOD_TIME '=' timespec ';'",
"serverhide_entry : SERVERHIDE '{' serverhide_items '}' ';'",
"serverhide_items : serverhide_items serverhide_item",
"serverhide_items : serverhide_item",
"serverhide_item : serverhide_flatten_links",
"serverhide_item : serverhide_hide_servers",
"serverhide_item : serverhide_links_delay",
"serverhide_item : serverhide_disable_hidden",
"serverhide_item : serverhide_hidden",
"serverhide_item : serverhide_hidden_name",
"serverhide_item : serverhide_hide_server_ips",
"serverhide_item : error",
"serverhide_flatten_links : FLATTEN_LINKS '=' TBOOL ';'",
"serverhide_hide_servers : HIDE_SERVERS '=' TBOOL ';'",
"serverhide_hidden_name : HIDDEN_NAME '=' QSTRING ';'",
"serverhide_links_delay : LINKS_DELAY '=' timespec ';'",
"serverhide_hidden : HIDDEN '=' TBOOL ';'",
"serverhide_disable_hidden : DISABLE_HIDDEN '=' TBOOL ';'",
"serverhide_hide_server_ips : HIDE_SERVER_IPS '=' TBOOL ';'",
};
#endif
#if YYDEBUG
#include <stdio.h>
#endif

/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH  10000
#endif
#endif

#define YYINITSTACKSIZE 500

int      yydebug;
int      yynerrs;
int      yyerrflag;
int      yychar;
short   *yyssp;
YYSTYPE *yyvsp;
YYSTYPE  yyval;
YYSTYPE  yylval;

/* variables for the parser stack */
static short   *yyss;
static short   *yysslim;
static YYSTYPE *yyvs;
static int      yystacksize;
/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(void)
{
    int newsize, i;
    short *newss;
    YYSTYPE *newvs;

    if ((newsize = yystacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = yyssp - yyss;
    newss = (yyss != 0)
          ? (short *)realloc(yyss, newsize * sizeof(*newss))
          : (short *)malloc(newsize * sizeof(*newss));
    if (newss == 0)
        return -1;

    yyss  = newss;
    yyssp = newss + i;
    newvs = (yyvs != 0)
          ? (YYSTYPE *)realloc(yyvs, newsize * sizeof(*newvs))
          : (YYSTYPE *)malloc(newsize * sizeof(*newvs));
    if (newvs == 0)
        return -1;

    yyvs = newvs;
    yyvsp = newvs + i;
    yystacksize = newsize;
    yysslim = yyss + newsize - 1;
    return 0;
}

#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse(void)
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;

    if (yyss == NULL && yygrowstack()) goto yyoverflow;
    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yysslim && yygrowstack())
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;

    yyerror("syntax error");

#ifdef lint
    goto yyerrlab;
#endif

yyerrlab:
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yysslim && yygrowstack())
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    if (yym)
        yyval = yyvsp[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
    switch (yyn)
    {
case 26:
#line 444 "ircd_parser.y"
{ yyval.number = 0; }
break;
case 28:
#line 446 "ircd_parser.y"
{
			yyval.number = yyvsp[-1].number + yyvsp[0].number;
		}
break;
case 29:
#line 450 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number + yyvsp[0].number;
		}
break;
case 30:
#line 454 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 + yyvsp[0].number;
		}
break;
case 31:
#line 458 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 * 60 + yyvsp[0].number;
		}
break;
case 32:
#line 462 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 * 60 * 24 + yyvsp[0].number;
		}
break;
case 33:
#line 466 "ircd_parser.y"
{
			yyval.number = yyvsp[-2].number * 60 * 60 * 24 * 7 + yyvsp[0].number;
		}
break;
case 34:
#line 471 "ircd_parser.y"
{ yyval.number = 0; }
break;
case 36:
#line 472 "ircd_parser.y"
{ yyval.number = yyvsp[-1].number + yyvsp[0].number; }
break;
case 37:
#line 473 "ircd_parser.y"
{ yyval.number = yyvsp[-2].number + yyvsp[0].number; }
break;
case 38:
#line 474 "ircd_parser.y"
{ yyval.number = yyvsp[-2].number * 1024 + yyvsp[0].number; }
break;
case 39:
#line 475 "ircd_parser.y"
{ yyval.number = yyvsp[-2].number * 1024 * 1024 + yyvsp[0].number; }
break;
case 46:
#line 489 "ircd_parser.y"
{
#ifndef STATIC_MODULES /* NOOP in the static case */
  if (ypass == 2)
  {
    char *m_bn;

    m_bn = basename(yylval.string);

    /* I suppose we should just ignore it if it is already loaded(since
     * otherwise we would flood the opers on rehash) -A1kmm.
     */
    add_conf_module(yylval.string);
  }
#endif
}
break;
case 47:
#line 506 "ircd_parser.y"
{
#ifndef STATIC_MODULES
  if (ypass == 2)
    mod_add_path(yylval.string);
#endif
}
break;
case 48:
#line 518 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(DNSBL_TYPE);
    yy_dconf = map_to_conf(yy_conf);
  }
  else
  {
    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 49:
#line 530 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_dconf->reason == NULL)
      delete_conf_item(yy_conf);
  }
}
break;
case 56:
#line 543 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 57:
#line 552 "ircd_parser.y"
{
  if (ypass == 2)
    yy_dconf->duration = yyvsp[-1].number;
}
break;
case 58:
#line 558 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_dconf->reason);
    DupString(yy_dconf->reason, yylval.string);
  }
}
break;
case 74:
#line 583 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2 && ServerInfo.ctx) 
  {
    if (!ServerInfo.rsa_private_key_file)
    {
      yyerror("No rsa_private_key_file specified, SSL disabled");
      break;
    }

    if (SSL_CTX_use_certificate_file(ServerInfo.ctx,
      yylval.string, SSL_FILETYPE_PEM) <= 0)
    {
      yyerror(ERR_lib_error_string(ERR_get_error()));
      break;
    }

    if (SSL_CTX_use_PrivateKey_file(ServerInfo.ctx,
      ServerInfo.rsa_private_key_file, SSL_FILETYPE_PEM) <= 0)
    {
      yyerror(ERR_lib_error_string(ERR_get_error()));
      break;
    }

    if (!SSL_CTX_check_private_key(ServerInfo.ctx))
    {
      yyerror("RSA private key does not match the SSL certificate public key!");
      break;
    }
  }
#endif
}
break;
case 75:
#line 617 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 1)
  {
    BIO *file;

    if (ServerInfo.rsa_private_key)
    {
      RSA_free(ServerInfo.rsa_private_key);
      ServerInfo.rsa_private_key = NULL;
    }

    if (ServerInfo.rsa_private_key_file)
    {
      MyFree(ServerInfo.rsa_private_key_file);
      ServerInfo.rsa_private_key_file = NULL;
    }

    DupString(ServerInfo.rsa_private_key_file, yylval.string);

    if ((file = BIO_new_file(yylval.string, "r")) == NULL)
    {
      yyerror("File open failed, ignoring");
      break;
    }

    ServerInfo.rsa_private_key = (RSA *)PEM_read_bio_RSAPrivateKey(file, NULL,
      0, NULL);

    (void)BIO_set_close(file, BIO_CLOSE);
    BIO_free(file);

    if (ServerInfo.rsa_private_key == NULL)
    {
      yyerror("Couldn't extract key, ignoring");
      break;
    }

    if (!RSA_check_key(ServerInfo.rsa_private_key))
    {
      RSA_free(ServerInfo.rsa_private_key);
      ServerInfo.rsa_private_key = NULL;

      yyerror("Invalid key, ignoring");
      break;
    }

    /* require 2048 bit (256 byte) key */
    if (RSA_size(ServerInfo.rsa_private_key) != 256)
    {
      RSA_free(ServerInfo.rsa_private_key);
      ServerInfo.rsa_private_key = NULL;

      yyerror("Not a 2048 bit key, ignoring");
    }
  }
#endif
}
break;
case 76:
#line 677 "ircd_parser.y"
{
  /* this isn't rehashable */
  if (ypass == 2)
  {
    if (ServerInfo.name == NULL)
    {
      /* the ircd will exit() in main() if we dont set one */
      if (strlen(yylval.string) <= HOSTLEN)
        DupString(ServerInfo.name, yylval.string);
    }
  }
}
break;
case 77:
#line 691 "ircd_parser.y"
{
  /* this isn't rehashable */
  if (ypass == 2 && !ServerInfo.sid)
  {
    if (valid_sid(yylval.string))
      DupString(ServerInfo.sid, yylval.string);
    else
    {
      ilog(L_ERROR, "Ignoring config file entry SID -- invalid SID. Aborting.");
      exit(0);
    }
  }
}
break;
case 78:
#line 706 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ServerInfo.description);
    DupString(ServerInfo.description,yylval.string);
  }
}
break;
case 79:
#line 715 "ircd_parser.y"
{
  if (ypass == 2)
  {
    char *p;

    if ((p = strchr(yylval.string, ' ')) != NULL)
      p = '\0';

    MyFree(ServerInfo.network_name);
    DupString(ServerInfo.network_name, yylval.string);
  }
}
break;
case 80:
#line 729 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ServerInfo.network_desc);
    DupString(ServerInfo.network_desc, yylval.string);
  }
}
break;
case 81:
#line 738 "ircd_parser.y"
{
  if (ypass == 2 && *yylval.string != '*')
  {
    struct addrinfo hints, *res;

    memset(&hints, 0, sizeof(hints));

    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_NUMERICHOST;

    if (irc_getaddrinfo(yylval.string, NULL, &hints, &res))
      ilog(L_ERROR, "Invalid netmask for server vhost(%s)", yylval.string);
    else
    {
      assert(res != NULL);

      memcpy(&ServerInfo.ip, res->ai_addr, res->ai_addrlen);
      ServerInfo.ip.ss.ss_family = res->ai_family;
      ServerInfo.ip.ss_len = res->ai_addrlen;
      irc_freeaddrinfo(res);

      ServerInfo.specific_ipv4_vhost = 1;
    }
  }
}
break;
case 82:
#line 766 "ircd_parser.y"
{
#ifdef IPV6
  if (ypass == 2 && *yylval.string != '*')
  {
    struct addrinfo hints, *res;

    memset(&hints, 0, sizeof(hints));

    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_NUMERICHOST;

    if (irc_getaddrinfo(yylval.string, NULL, &hints, &res))
      ilog(L_ERROR, "Invalid netmask for server vhost6(%s)", yylval.string);
    else
    {
      assert(res != NULL);

      memcpy(&ServerInfo.ip6, res->ai_addr, res->ai_addrlen);
      ServerInfo.ip6.ss.ss_family = res->ai_family;
      ServerInfo.ip6.ss_len = res->ai_addrlen;
      irc_freeaddrinfo(res);

      ServerInfo.specific_ipv6_vhost = 1;
    }
  }
#endif
}
break;
case 83:
#line 796 "ircd_parser.y"
{
  if (ypass == 2)
  {
    recalc_fdlimit(NULL);

    if (yyvsp[-1].number < MAXCLIENTS_MIN)
    {
      char buf[IRCD_BUFSIZE];
      ircsprintf(buf, "MAXCLIENTS too low, setting to %d", MAXCLIENTS_MIN);
      yyerror(buf);
    }
    else if (yyvsp[-1].number > MAXCLIENTS_MAX)
    {
      char buf[IRCD_BUFSIZE];
      ircsprintf(buf, "MAXCLIENTS too high, setting to %d", MAXCLIENTS_MAX);
      yyerror(buf);
    }
    else
      ServerInfo.max_clients = yyvsp[-1].number;
  }
}
break;
case 84:
#line 819 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
    {
      /* Don't become a hub if we have a lazylink active. */
      if (!ServerInfo.hub && uplink && IsCapable(uplink, CAP_LL))
      {
        sendto_realops_flags(UMODE_ALL, L_ALL,
                             "Ignoring config file line hub=yes; "
                             "due to active LazyLink (%s)", uplink->name);
      }
      else
      {
        ServerInfo.hub = 1;
        uplink = NULL;
        delete_capability("HUB");
        add_capability("HUB", CAP_HUB, 1);
      }
    }
    else if (ServerInfo.hub)
    {
      dlink_node *ptr = NULL;

      ServerInfo.hub = 0;
      delete_capability("HUB");

      /* Don't become a leaf if we have a lazylink active. */
      DLINK_FOREACH(ptr, serv_list.head)
      {
        const struct Client *acptr = ptr->data;
        if (MyConnect(acptr) && IsCapable(acptr, CAP_LL))
        {
          sendto_realops_flags(UMODE_ALL, L_ALL,
                               "Ignoring config file line hub=no; "
                               "due to active LazyLink (%s)",
                               acptr->name);
          add_capability("HUB", CAP_HUB, 1);
          ServerInfo.hub = 1;
          break;
        }
      }
    }
  }
}
break;
case 92:
#line 875 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(AdminInfo.name);
    DupString(AdminInfo.name, yylval.string);
  }
}
break;
case 93:
#line 884 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(AdminInfo.email);
    DupString(AdminInfo.email, yylval.string);
  }
}
break;
case 94:
#line 893 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(AdminInfo.description);
    DupString(AdminInfo.description, yylval.string);
  }
}
break;
case 111:
#line 920 "ircd_parser.y"
{
                        }
break;
case 112:
#line 924 "ircd_parser.y"
{
                        }
break;
case 113:
#line 928 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.userlog, yylval.string,
            sizeof(ConfigLoggingEntry.userlog));
}
break;
case 114:
#line 935 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.failed_operlog, yylval.string,
            sizeof(ConfigLoggingEntry.failed_operlog));
}
break;
case 115:
#line 942 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.operlog, yylval.string,
            sizeof(ConfigLoggingEntry.operlog));
}
break;
case 116:
#line 949 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.operspylog, yylval.string,
            sizeof(ConfigLoggingEntry.operspylog));
}
break;
case 117:
#line 956 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.glinelog, yylval.string,
            sizeof(ConfigLoggingEntry.glinelog));
}
break;
case 118:
#line 963 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.klinelog, yylval.string,
            sizeof(ConfigLoggingEntry.klinelog));
}
break;
case 119:
#line 970 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.ioerrlog, yylval.string,
            sizeof(ConfigLoggingEntry.ioerrlog));
}
break;
case 120:
#line 977 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(ConfigLoggingEntry.killlog, yylval.string,
            sizeof(ConfigLoggingEntry.killlog));
}
break;
case 121:
#line 984 "ircd_parser.y"
{ 
  if (ypass == 2)
    set_log_level(L_CRIT);
}
break;
case 122:
#line 988 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_ERROR);
}
break;
case 123:
#line 992 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_WARN);
}
break;
case 124:
#line 996 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_NOTICE);
}
break;
case 125:
#line 1000 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_TRACE);
}
break;
case 126:
#line 1004 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_INFO);
}
break;
case 127:
#line 1008 "ircd_parser.y"
{
  if (ypass == 2)
    set_log_level(L_DEBUG);
}
break;
case 128:
#line 1014 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigLoggingEntry.use_logging = yylval.number;
}
break;
case 129:
#line 1023 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(OPER_TYPE);
    yy_aconf = map_to_conf(yy_conf);
    SetConfEncrypted(yy_aconf); /* Yes, the default is encrypted */
  }
  else
  {
    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 130:
#line 1036 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;
    dlink_node *ptr;
    dlink_node *next_ptr;

    if (yy_aconf->user && yy_aconf->host)
      conf_add_class_to_conf(yy_conf, class_name);
    else
      delete_conf_item(yy_conf);

    /* Now, make sure there is a copy of the "base" given oper
     * block in each of the collected copies
     */

    DLINK_FOREACH_SAFE(ptr, next_ptr, col_conf_list.head)
    {
      struct AccessItem *new_aconf;
      struct ConfItem *new_conf;
      yy_tmp = ptr->data;

      new_conf = make_conf_item(OPER_TYPE);
      new_aconf = (struct AccessItem *)map_to_conf(new_conf);

      new_aconf->flags = yy_aconf->flags;

      if (yy_conf->name != NULL)
        DupString(new_conf->name, yy_conf->name);
      if (yy_tmp->user != NULL)
	DupString(new_aconf->user, yy_tmp->user);
      else
	DupString(new_aconf->user, "*");
      if (yy_tmp->host != NULL)
	DupString(new_aconf->host, yy_tmp->host);
      else
	DupString(new_aconf->host, "*");
      conf_add_class_to_conf(new_conf, class_name);
      if (yy_aconf->passwd != NULL)
        DupString(new_aconf->passwd, yy_aconf->passwd);

      new_aconf->port = yy_aconf->port;
#ifdef HAVE_LIBCRYPTO
      if (yy_aconf->rsa_public_key_file != NULL)
      {
        BIO *file;

        DupString(new_aconf->rsa_public_key_file,
		  yy_aconf->rsa_public_key_file);

        file = BIO_new_file(yy_aconf->rsa_public_key_file, "r");
        new_aconf->rsa_public_key = (RSA *)PEM_read_bio_RSA_PUBKEY(file, 
							   NULL, 0, NULL);
        (void)BIO_set_close(file, BIO_CLOSE);
        BIO_free(file);
      }
      if (yy_aconf->certfp != NULL)
      {
        new_aconf->certfp = MyMalloc(SHA_DIGEST_LENGTH);
        memcpy(new_aconf->certfp, yy_aconf->certfp, SHA_DIGEST_LENGTH);
      }
#endif

#ifdef HAVE_LIBCRYPTO
      if (yy_tmp->name && (yy_tmp->passwd || yy_aconf->rsa_public_key)
	  && yy_tmp->host)
#else
      if (yy_tmp->name && yy_tmp->passwd && yy_tmp->host)
#endif
      {
        conf_add_class_to_conf(new_conf, class_name);
	if (yy_tmp->name != NULL)
	  DupString(new_conf->name, yy_tmp->name);
      }

      dlinkDelete(&yy_tmp->node, &col_conf_list);
      free_collect_item(yy_tmp);
    }

    yy_conf = NULL;
    yy_aconf = NULL;


    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 160:
#line 1136 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (strlen(yylval.string) > OPERNICKLEN)
      yylval.string[OPERNICKLEN] = '\0';

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 161:
#line 1148 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (strlen(yylval.string) > OPERNICKLEN)
      yylval.string[OPERNICKLEN] = '\0';

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 162:
#line 1160 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct split_nuh_item nuh;

    nuh.nuhmask  = yylval.string;
    nuh.nickptr  = NULL;
    nuh.userptr  = userbuf;
    nuh.hostptr  = hostbuf;
    
    nuh.nicksize = 0;
    nuh.usersize = sizeof(userbuf);
    nuh.hostsize = sizeof(hostbuf);

    split_nuh(&nuh);

    if (yy_aconf->user == NULL)
    {
      DupString(yy_aconf->user, userbuf);
      DupString(yy_aconf->host, hostbuf);
    }
    else
    {
      struct CollectItem *yy_tmp = MyMalloc(sizeof(struct CollectItem));

      DupString(yy_tmp->user, userbuf);
      DupString(yy_tmp->host, hostbuf);

      dlinkAdd(yy_tmp, &yy_tmp->node, &col_conf_list);
    }
  }
}
break;
case 163:
#line 1194 "ircd_parser.y"
{
  if (ypass == 2)
  {
#ifdef HAVE_LIBCRYPTO
    char tmp[SHA_DIGEST_LENGTH];
    
    if(yy_aconf->certfp != NULL)
      MyFree(yy_aconf->certfp);

    if(base16_decode(tmp, SHA_DIGEST_LENGTH, yylval.string, strlen(yylval.string)) != 0)
    {
      yyerror("Invalid client certificate fingerprint provided. Ignoring");
      break;
    }
    yy_aconf->certfp = MyMalloc(SHA_DIGEST_LENGTH);
    memcpy(yy_aconf->certfp, tmp, SHA_DIGEST_LENGTH);
#endif
  }
}
break;
case 164:
#line 1215 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->passwd != NULL)
      memset(yy_aconf->passwd, 0, strlen(yy_aconf->passwd));

    MyFree(yy_aconf->passwd);
    DupString(yy_aconf->passwd, yylval.string);
  }
}
break;
case 165:
#line 1227 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      SetConfEncrypted(yy_aconf);
    else
      ClearConfEncrypted(yy_aconf);
  }
}
break;
case 166:
#line 1238 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    BIO *file;

    if (yy_aconf->rsa_public_key != NULL)
    {
      RSA_free(yy_aconf->rsa_public_key);
      yy_aconf->rsa_public_key = NULL;
    }

    if (yy_aconf->rsa_public_key_file != NULL)
    {
      MyFree(yy_aconf->rsa_public_key_file);
      yy_aconf->rsa_public_key_file = NULL;
    }

    DupString(yy_aconf->rsa_public_key_file, yylval.string);
    file = BIO_new_file(yylval.string, "r");

    if (file == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- file doesn't exist");
      break;
    }

    yy_aconf->rsa_public_key = (RSA *)PEM_read_bio_RSA_PUBKEY(file, NULL, 0, NULL);

    if (yy_aconf->rsa_public_key == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- Key invalid; check key syntax.");
      break;
    }

    (void)BIO_set_close(file, BIO_CLOSE);
    BIO_free(file);
  }
#endif /* HAVE_LIBCRYPTO */
}
break;
case 167:
#line 1280 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(class_name);
    DupString(class_name, yylval.string);
  }
}
break;
case 168:
#line 1289 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes = 0;
}
break;
case 172:
#line 1296 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_BOTS;
}
break;
case 173:
#line 1300 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_CCONN;
}
break;
case 174:
#line 1304 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_NOCTCP;
}
break;
case 175:
#line 1308 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_DEAF;
}
break;
case 176:
#line 1312 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_DEBUG;
}
break;
case 177:
#line 1316 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_FULL;
}
break;
case 178:
#line 1320 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_SKILL;
}
break;
case 179:
#line 1324 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_NCHANGE;
}
break;
case 180:
#line 1328 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_REJ;
}
break;
case 181:
#line 1332 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_UNAUTH;
}
break;
case 182:
#line 1336 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_SPY;
}
break;
case 183:
#line 1340 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_EXTERNAL;
}
break;
case 184:
#line 1344 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_OPERWALL;
}
break;
case 185:
#line 1348 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_SERVNOTICE;
}
break;
case 186:
#line 1352 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_INVISIBLE;
}
break;
case 187:
#line 1356 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_WALLOP;
}
break;
case 188:
#line 1360 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_SOFTCALLERID;
}
break;
case 189:
#line 1364 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_CALLERID;
}
break;
case 190:
#line 1368 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_LOCOPS;
}
break;
case 191:
#line 1372 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_HIDECHANNELS;
}
break;
case 192:
#line 1376 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->modes |= UMODE_FARCONNECT;
}
break;
case 193:
#line 1382 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_GLOBAL_KILL;
    else
      yy_aconf->port &= ~OPER_FLAG_GLOBAL_KILL;
  }
}
break;
case 194:
#line 1393 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_REMOTE;
    else
      yy_aconf->port &= ~OPER_FLAG_REMOTE; 
  }
}
break;
case 195:
#line 1404 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_REMOTEBAN;
    else
      yy_aconf->port &= ~OPER_FLAG_REMOTEBAN;
  }
}
break;
case 196:
#line 1415 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_K;
    else
      yy_aconf->port &= ~OPER_FLAG_K;
  }
}
break;
case 197:
#line 1426 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_X;
    else
      yy_aconf->port &= ~OPER_FLAG_X;
  }
}
break;
case 198:
#line 1437 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_UNKLINE;
    else
      yy_aconf->port &= ~OPER_FLAG_UNKLINE; 
  }
}
break;
case 199:
#line 1448 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_GLINE;
    else
      yy_aconf->port &= ~OPER_FLAG_GLINE;
  }
}
break;
case 200:
#line 1459 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_N;
    else
      yy_aconf->port &= ~OPER_FLAG_N;
  }
}
break;
case 201:
#line 1470 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_DIE;
    else
      yy_aconf->port &= ~OPER_FLAG_DIE;
  }
}
break;
case 202:
#line 1481 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_REHASH;
    else
      yy_aconf->port &= ~OPER_FLAG_REHASH;
  }
}
break;
case 203:
#line 1492 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_ADMIN;
    else
      yy_aconf->port &= ~OPER_FLAG_ADMIN;
  }
}
break;
case 204:
#line 1503 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_HIDDEN_ADMIN;
    else
      yy_aconf->port &= ~OPER_FLAG_HIDDEN_ADMIN;
  }
}
break;
case 205:
#line 1514 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_HIDDEN_OPER;
    else
      yy_aconf->port &= ~OPER_FLAG_HIDDEN_OPER;
  }
}
break;
case 206:
#line 1525 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_OPER_SPY;
    else
      yy_aconf->port &= ~OPER_FLAG_OPER_SPY;
  }
}
break;
case 207:
#line 1536 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->port |= OPER_FLAG_OPERWALL;
    else
      yy_aconf->port &= ~OPER_FLAG_OPERWALL;
  }
}
break;
case 208:
#line 1547 "ircd_parser.y"
{
}
break;
case 212:
#line 1551 "ircd_parser.y"
{ not_atom = 1; }
break;
case 214:
#line 1552 "ircd_parser.y"
{ not_atom = 0; }
break;
case 216:
#line 1555 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)yy_aconf->port &= ~OPER_FLAG_GLOBAL_KILL;
    else yy_aconf->port |= OPER_FLAG_GLOBAL_KILL;
  }
}
break;
case 217:
#line 1562 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_REMOTE;
    else yy_aconf->port |= OPER_FLAG_REMOTE;
  }
}
break;
case 218:
#line 1569 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_K;
    else yy_aconf->port |= OPER_FLAG_K;
  }
}
break;
case 219:
#line 1576 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_UNKLINE;
    else yy_aconf->port |= OPER_FLAG_UNKLINE;
  } 
}
break;
case 220:
#line 1583 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_X;
    else yy_aconf->port |= OPER_FLAG_X;
  }
}
break;
case 221:
#line 1590 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_GLINE;
    else yy_aconf->port |= OPER_FLAG_GLINE;
  }
}
break;
case 222:
#line 1597 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_DIE;
    else yy_aconf->port |= OPER_FLAG_DIE;
  }
}
break;
case 223:
#line 1604 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_REHASH;
    else yy_aconf->port |= OPER_FLAG_REHASH;
  }
}
break;
case 224:
#line 1611 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_ADMIN;
    else yy_aconf->port |= OPER_FLAG_ADMIN;
  }
}
break;
case 225:
#line 1618 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_HIDDEN_ADMIN;
    else yy_aconf->port |= OPER_FLAG_HIDDEN_ADMIN;
  }
}
break;
case 226:
#line 1625 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_N;
    else yy_aconf->port |= OPER_FLAG_N;
  }
}
break;
case 227:
#line 1632 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_OPERWALL;
    else yy_aconf->port |= OPER_FLAG_OPERWALL;
  }
}
break;
case 228:
#line 1639 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_OPER_SPY;
    else yy_aconf->port |= OPER_FLAG_OPER_SPY;
  }
}
break;
case 229:
#line 1646 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_HIDDEN_OPER;
    else yy_aconf->port |= OPER_FLAG_HIDDEN_OPER;
  }
}
break;
case 230:
#line 1653 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_REMOTEBAN;
    else yy_aconf->port |= OPER_FLAG_REMOTEBAN;
  }
}
break;
case 231:
#line 1660 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) ClearConfEncrypted(yy_aconf);
    else SetConfEncrypted(yy_aconf);
  }
}
break;
case 232:
#line 1667 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->port &= ~OPER_FLAG_FARCONNECT;
    else yy_aconf->port |= OPER_FLAG_FARCONNECT;
  }
}
break;
case 233:
#line 1680 "ircd_parser.y"
{
  if (ypass == 1)
  {
    yy_conf = make_conf_item(CLASS_TYPE);
    yy_class = map_to_conf(yy_conf);
  }
}
break;
case 234:
#line 1687 "ircd_parser.y"
{
  if (ypass == 1)
  {
    struct ConfItem *cconf = NULL;
    struct ClassItem *class = NULL;

    if (yy_class_name == NULL)
      delete_conf_item(yy_conf);
    else
    {
      cconf = find_exact_name_conf(CLASS_TYPE, yy_class_name, NULL, NULL, NULL);

      if (cconf != NULL)		/* The class existed already */
      {
        int user_count = 0;

        rebuild_cidr_class(cconf, yy_class);

        class = map_to_conf(cconf);

        user_count = class->curr_user_count;
        memcpy(class, yy_class, sizeof(*class));
        class->curr_user_count = user_count;
        class->active = 1;

        delete_conf_item(yy_conf);

        MyFree(cconf->name);            /* Allows case change of class name */
        cconf->name = yy_class_name;
      }
      else	/* Brand new class */
      {
        MyFree(yy_conf->name);          /* just in case it was allocated */
        yy_conf->name = yy_class_name;
	yy_class->active = 1;
      }
    }
    yy_class_name = NULL;
  }
}
break;
case 253:
#line 1746 "ircd_parser.y"
{
  if (ypass == 1)
  {
    MyFree(yy_class_name);
    DupString(yy_class_name, yylval.string);
  }
}
break;
case 254:
#line 1755 "ircd_parser.y"
{
  if (ypass == 1)
  {
    MyFree(yy_class_name);
    DupString(yy_class_name, yylval.string);
  }
}
break;
case 255:
#line 1764 "ircd_parser.y"
{
  if (ypass == 1)
    PingFreq(yy_class) = yyvsp[-1].number;
}
break;
case 256:
#line 1770 "ircd_parser.y"
{
  if (ypass == 1)
    PingWarning(yy_class) = yyvsp[-1].number;
}
break;
case 257:
#line 1776 "ircd_parser.y"
{
  if (ypass == 1)
    MaxPerIp(yy_class) = yyvsp[-1].number;
}
break;
case 258:
#line 1782 "ircd_parser.y"
{
  if (ypass == 1)
    ConFreq(yy_class) = yyvsp[-1].number;
}
break;
case 259:
#line 1788 "ircd_parser.y"
{
  if (ypass == 1)
    MaxTotal(yy_class) = yyvsp[-1].number;
}
break;
case 260:
#line 1794 "ircd_parser.y"
{
  if (ypass == 1)
    MaxGlobal(yy_class) = yyvsp[-1].number;
}
break;
case 261:
#line 1800 "ircd_parser.y"
{
  if (ypass == 1)
    MaxLocal(yy_class) = yyvsp[-1].number;
}
break;
case 262:
#line 1806 "ircd_parser.y"
{
  if (ypass == 1)
    MaxIdent(yy_class) = yyvsp[-1].number;
}
break;
case 263:
#line 1812 "ircd_parser.y"
{
  if (ypass == 1)
    MaxSendq(yy_class) = yyvsp[-1].number;
}
break;
case 264:
#line 1818 "ircd_parser.y"
{
  if (ypass == 1)
    CidrBitlenIPV4(yy_class) = yyvsp[-1].number;
}
break;
case 265:
#line 1824 "ircd_parser.y"
{
  if (ypass == 1)
    CidrBitlenIPV6(yy_class) = yyvsp[-1].number;
}
break;
case 266:
#line 1830 "ircd_parser.y"
{
  if (ypass == 1)
    NumberPerCidr(yy_class) = yyvsp[-1].number;
}
break;
case 267:
#line 1839 "ircd_parser.y"
{
  if (ypass == 2)
  {
    listener_address = NULL;
    listener_flags = 0;
  }
}
break;
case 268:
#line 1846 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(listener_address);
    listener_address = NULL;
  }
}
break;
case 269:
#line 1855 "ircd_parser.y"
{
  listener_flags = 0;
}
break;
case 273:
#line 1861 "ircd_parser.y"
{
  if (ypass == 2)
    listener_flags |= LISTENER_SSL;
}
break;
case 274:
#line 1865 "ircd_parser.y"
{
  if (ypass == 2)
    listener_flags |= LISTENER_HIDDEN;
}
break;
case 282:
#line 1873 "ircd_parser.y"
{ listener_flags = 0; }
break;
case 286:
#line 1878 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if ((listener_flags & LISTENER_SSL))
#ifdef HAVE_LIBCRYPTO
      if (!ServerInfo.ctx)
#endif
      {
        yyerror("SSL not available - port closed");
	break;
      }
    add_listener(yyvsp[0].number, listener_address, listener_flags);
  }
}
break;
case 287:
#line 1892 "ircd_parser.y"
{
  if (ypass == 2)
  {
    int i;

    if ((listener_flags & LISTENER_SSL))
#ifdef HAVE_LIBCRYPTO
      if (!ServerInfo.ctx)
#endif
      {
        yyerror("SSL not available - port closed");
	break;
      }

    for (i = yyvsp[-2].number; i <= yyvsp[0].number; ++i)
      add_listener(i, listener_address, listener_flags);
  }
}
break;
case 288:
#line 1912 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(listener_address);
    DupString(listener_address, yylval.string);
  }
}
break;
case 289:
#line 1921 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(listener_address);
    DupString(listener_address, yylval.string);
  }
}
break;
case 290:
#line 1933 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(CLIENT_TYPE);
    yy_aconf = map_to_conf(yy_conf);
  }
  else
  {
    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 291:
#line 1945 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp = NULL;
    dlink_node *ptr = NULL, *next_ptr = NULL;

    if (yy_aconf->user && yy_aconf->host)
    {
      conf_add_class_to_conf(yy_conf, class_name);
      add_conf_by_address(CONF_CLIENT, yy_aconf);
    }
    else
      delete_conf_item(yy_conf);

    /* copy over settings from first struct */
    DLINK_FOREACH_SAFE(ptr, next_ptr, col_conf_list.head)
    {
      struct AccessItem *new_aconf;
      struct ConfItem *new_conf;

      new_conf = make_conf_item(CLIENT_TYPE);
      new_aconf = map_to_conf(new_conf);

      yy_tmp = ptr->data;

      assert(yy_tmp->user && yy_tmp->host);

      if (yy_aconf->passwd != NULL)
        DupString(new_aconf->passwd, yy_aconf->passwd);
      if (yy_conf->name != NULL)
        DupString(new_conf->name, yy_conf->name);
      if (yy_aconf->passwd != NULL)
        DupString(new_aconf->passwd, yy_aconf->passwd);

      new_aconf->flags = yy_aconf->flags;
      new_aconf->port  = yy_aconf->port;

      DupString(new_aconf->user, yy_tmp->user);
      collapse(new_aconf->user);

      DupString(new_aconf->host, yy_tmp->host);
      collapse(new_aconf->host);

#ifdef HAVE_LIBCRYPTO
      if (yy_aconf->certfp != NULL)
      {
        new_aconf->certfp = MyMalloc(SHA_DIGEST_LENGTH);
        memcpy(new_aconf->certfp, yy_aconf->certfp, SHA_DIGEST_LENGTH);
      }
#endif

      conf_add_class_to_conf(new_conf, class_name);
      add_conf_by_address(CONF_CLIENT, new_aconf);
      dlinkDelete(&yy_tmp->node, &col_conf_list);
      free_collect_item(yy_tmp);
    }

    MyFree(class_name);
    class_name = NULL;
    yy_conf = NULL;
    yy_aconf = NULL;
  }
}
break;
case 313:
#line 2018 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp = NULL;
    struct split_nuh_item nuh;

    nuh.nuhmask  = yylval.string;
    nuh.nickptr  = NULL;
    nuh.userptr  = userbuf;
    nuh.hostptr  = hostbuf;

    nuh.nicksize = 0;
    nuh.usersize = sizeof(userbuf);
    nuh.hostsize = sizeof(hostbuf);

    split_nuh(&nuh);

    if (yy_aconf->user == NULL)
    {
      DupString(yy_aconf->user, userbuf);
      DupString(yy_aconf->host, hostbuf);
    }
    else
    {
      yy_tmp = MyMalloc(sizeof(struct CollectItem));

      DupString(yy_tmp->user, userbuf);
      DupString(yy_tmp->host, hostbuf);

      dlinkAdd(yy_tmp, &yy_tmp->node, &col_conf_list);
    }
  }
}
break;
case 314:
#line 2055 "ircd_parser.y"
{
  if (ypass == 2)
  {
    /* be paranoid */
    if (yy_aconf->passwd != NULL)
      memset(yy_aconf->passwd, 0, strlen(yy_aconf->passwd));

    MyFree(yy_aconf->passwd);
    DupString(yy_aconf->passwd, yylval.string);
  }
}
break;
case 315:
#line 2068 "ircd_parser.y"
{
  if (ypass == 2)
  {
#ifdef HAVE_LIBCRYPTO
    char tmp[SHA_DIGEST_LENGTH];

    if(yy_aconf->certfp != NULL)
      MyFree(yy_aconf->certfp);

    if(base16_decode(tmp, SHA_DIGEST_LENGTH, yylval.string, strlen(yylval.string)) != 0)
    {
      yyerror("Invalid client certificate fingerprint provided. Ignoring");
      break;
    }
    yy_aconf->certfp = MyMalloc(SHA_DIGEST_LENGTH);
    memcpy(yy_aconf->certfp, tmp, SHA_DIGEST_LENGTH);
#endif
  }
}
break;
case 316:
#line 2089 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_SPOOF_NOTICE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_SPOOF_NOTICE;
  }
}
break;
case 317:
#line 2100 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(class_name);
    DupString(class_name, yylval.string);
  }
}
break;
case 318:
#line 2109 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      SetConfEncrypted(yy_aconf);
    else
      ClearConfEncrypted(yy_aconf);
  }
}
break;
case 319:
#line 2120 "ircd_parser.y"
{
}
break;
case 323:
#line 2124 "ircd_parser.y"
{ not_atom = 1; }
break;
case 325:
#line 2125 "ircd_parser.y"
{ not_atom = 0; }
break;
case 327:
#line 2128 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_SPOOF_NOTICE;
    else yy_aconf->flags |= CONF_FLAGS_SPOOF_NOTICE;
  }

}
break;
case 328:
#line 2136 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NOLIMIT;
    else yy_aconf->flags |= CONF_FLAGS_NOLIMIT;
  }
}
break;
case 329:
#line 2143 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_EXEMPTKLINE;
    else yy_aconf->flags |= CONF_FLAGS_EXEMPTKLINE;
  } 
}
break;
case 330:
#line 2150 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NEED_IDENTD;
    else yy_aconf->flags |= CONF_FLAGS_NEED_IDENTD;
  }
}
break;
case 331:
#line 2157 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_CAN_FLOOD;
    else yy_aconf->flags |= CONF_FLAGS_CAN_FLOOD;
  }
}
break;
case 332:
#line 2164 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_IDLE_LINED;
    else yy_aconf->flags |= CONF_FLAGS_IDLE_LINED;
  }
}
break;
case 333:
#line 2171 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NO_TILDE;
    else yy_aconf->flags |= CONF_FLAGS_NO_TILDE;
  } 
}
break;
case 334:
#line 2178 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_EXEMPTGLINE;
    else yy_aconf->flags |= CONF_FLAGS_EXEMPTGLINE;
  } 
}
break;
case 335:
#line 2185 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_EXEMPTRESV;
    else yy_aconf->flags |= CONF_FLAGS_EXEMPTRESV;
  }
}
break;
case 336:
#line 2192 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_WEBIRC;
    else yy_aconf->flags |= CONF_FLAGS_WEBIRC;
  }
}
break;
case 337:
#line 2199 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom) yy_aconf->flags &= ~CONF_FLAGS_NEED_PASSWORD;
    else yy_aconf->flags |= CONF_FLAGS_NEED_PASSWORD;
  }
}
break;
case 338:
#line 2208 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_EXEMPTKLINE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_EXEMPTKLINE;
  }
}
break;
case 339:
#line 2219 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NEED_IDENTD;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NEED_IDENTD;
  }
}
break;
case 340:
#line 2230 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NOLIMIT;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NOLIMIT;
  }
}
break;
case 341:
#line 2241 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_CAN_FLOOD;
    else
      yy_aconf->flags &= ~CONF_FLAGS_CAN_FLOOD;
  }
}
break;
case 342:
#line 2252 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NO_TILDE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NO_TILDE;
  }
}
break;
case 343:
#line 2263 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_EXEMPTGLINE;
    else
      yy_aconf->flags &= ~CONF_FLAGS_EXEMPTGLINE;
  }
}
break;
case 344:
#line 2275 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_conf->name);

    if (strlen(yylval.string) < HOSTLEN)
    {    
      DupString(yy_conf->name, yylval.string);
      yy_aconf->flags |= CONF_FLAGS_SPOOF_IP;
    }
    else
    {
      ilog(L_ERROR, "Spoofs must be less than %d..ignoring it", HOSTLEN);
      yy_conf->name = NULL;
    }
  }
}
break;
case 345:
#line 2294 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_aconf->flags |= CONF_FLAGS_REDIR;
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 346:
#line 2304 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_aconf->flags |= CONF_FLAGS_REDIR;
    yy_aconf->port = yyvsp[-1].number;
  }
}
break;
case 347:
#line 2313 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_WEBIRC;
    else
      yy_aconf->flags &= ~CONF_FLAGS_WEBIRC;
  }
}
break;
case 348:
#line 2324 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_NEED_PASSWORD;
    else
      yy_aconf->flags &= ~CONF_FLAGS_NEED_PASSWORD;
  }
}
break;
case 349:
#line 2339 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(resv_reason);
    resv_reason = NULL;
  }
}
break;
case 350:
#line 2346 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(resv_reason);
    resv_reason = NULL;
  }
}
break;
case 357:
#line 2358 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(resv_reason);
    DupString(resv_reason, yylval.string);
  }
}
break;
case 358:
#line 2367 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (IsChanPrefix(*yylval.string))
    {
      char def_reason[] = "No reason";

      create_channel_resv(yylval.string, resv_reason != NULL ? resv_reason : def_reason, 1);
    }
  }
  /* ignore it for now.. but we really should make a warning if
   * its an erroneous name --fl_ */
}
break;
case 359:
#line 2382 "ircd_parser.y"
{
  if (ypass == 2)
  {
    char def_reason[] = "No reason";

    create_nick_resv(yylval.string, resv_reason != NULL ? resv_reason : def_reason, 1);
  }
}
break;
case 360:
#line 2395 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(ULINE_TYPE);
    yy_match_item = map_to_conf(yy_conf);
    yy_match_item->action = SHARED_ALL;
  }
}
break;
case 361:
#line 2403 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = NULL;
  }
}
break;
case 368:
#line 2414 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 369:
#line 2423 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct split_nuh_item nuh;

    nuh.nuhmask  = yylval.string;
    nuh.nickptr  = NULL;
    nuh.userptr  = userbuf;
    nuh.hostptr  = hostbuf;

    nuh.nicksize = 0;
    nuh.usersize = sizeof(userbuf);
    nuh.hostsize = sizeof(hostbuf);

    split_nuh(&nuh);

    DupString(yy_match_item->user, userbuf);
    DupString(yy_match_item->host, hostbuf);
  }
}
break;
case 370:
#line 2445 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action = 0;
}
break;
case 374:
#line 2452 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_KLINE;
}
break;
case 375:
#line 2456 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_TKLINE;
}
break;
case 376:
#line 2460 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNKLINE;
}
break;
case 377:
#line 2464 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_XLINE;
}
break;
case 378:
#line 2468 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_TXLINE;
}
break;
case 379:
#line 2472 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNXLINE;
}
break;
case 380:
#line 2476 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_RESV;
}
break;
case 381:
#line 2480 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_TRESV;
}
break;
case 382:
#line 2484 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_UNRESV;
}
break;
case 383:
#line 2488 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_LOCOPS;
}
break;
case 384:
#line 2492 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_SERVICES;
}
break;
case 385:
#line 2496 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action |= SHARED_REHASH;
}
break;
case 386:
#line 2500 "ircd_parser.y"
{
  if (ypass == 2)
    yy_match_item->action = SHARED_ALL;
}
break;
case 387:
#line 2509 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(CLUSTER_TYPE);
    yy_conf->flags = SHARED_ALL;
  }
}
break;
case 388:
#line 2516 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_conf->name == NULL)
      DupString(yy_conf->name, "*");
    yy_conf = NULL;
  }
}
break;
case 394:
#line 2529 "ircd_parser.y"
{
  if (ypass == 2)
    DupString(yy_conf->name, yylval.string);
}
break;
case 395:
#line 2535 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags = 0;
}
break;
case 399:
#line 2542 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags |= SHARED_KLINE;
}
break;
case 400:
#line 2546 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags |= SHARED_TKLINE;
}
break;
case 401:
#line 2550 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags |= SHARED_UNKLINE;
}
break;
case 402:
#line 2554 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags |= SHARED_XLINE;
}
break;
case 403:
#line 2558 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags |= SHARED_TXLINE;
}
break;
case 404:
#line 2562 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags |= SHARED_UNXLINE;
}
break;
case 405:
#line 2566 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags |= SHARED_RESV;
}
break;
case 406:
#line 2570 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags |= SHARED_TRESV;
}
break;
case 407:
#line 2574 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags |= SHARED_UNRESV;
}
break;
case 408:
#line 2578 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags |= SHARED_LOCOPS;
}
break;
case 409:
#line 2582 "ircd_parser.y"
{
  if (ypass == 2)
    yy_conf->flags = SHARED_ALL;
}
break;
case 410:
#line 2591 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(SERVER_TYPE);
    yy_aconf = (struct AccessItem *)map_to_conf(yy_conf);
    yy_aconf->passwd = NULL;
    /* defaults */
    yy_aconf->port = PORTNUM;

    if (ConfigFileEntry.burst_away)
      yy_aconf->flags = CONF_FLAGS_BURST_AWAY;
  }
  else
  {
    MyFree(class_name);
    class_name = NULL;
  }
}
break;
case 411:
#line 2609 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_hconf=NULL;
    struct CollectItem *yy_lconf=NULL;
    dlink_node *ptr;
    dlink_node *next_ptr;
#ifdef HAVE_LIBCRYPTO
    if (yy_aconf->host &&
	((yy_aconf->passwd && yy_aconf->spasswd) ||
	 (yy_aconf->rsa_public_key && IsConfCryptLink(yy_aconf))))
#else /* !HAVE_LIBCRYPTO */
      if (yy_aconf->host && !IsConfCryptLink(yy_aconf) && 
	  yy_aconf->passwd && yy_aconf->spasswd)
#endif /* !HAVE_LIBCRYPTO */
	{
	  if (conf_add_server(yy_conf, class_name) == -1)
	  {
	    delete_conf_item(yy_conf);
	    yy_conf = NULL;
	    yy_aconf = NULL;
	  }
	}
	else
	{
	  /* Even if yy_conf ->name is NULL
	   * should still unhook any hub/leaf confs still pending
	   */
	  unhook_hub_leaf_confs();

	  if (yy_conf->name != NULL)
	  {
#ifndef HAVE_LIBCRYPTO
	    if (IsConfCryptLink(yy_aconf))
	      yyerror("Ignoring connect block -- no OpenSSL support");
#else
	    if (IsConfCryptLink(yy_aconf) && !yy_aconf->rsa_public_key)
	      yyerror("Ignoring connect block -- missing key");
#endif
	    if (yy_aconf->host == NULL)
	      yyerror("Ignoring connect block -- missing host");
	    else if (!IsConfCryptLink(yy_aconf) && 
		    (!yy_aconf->passwd || !yy_aconf->spasswd))
              yyerror("Ignoring connect block -- missing password");
	  }


          /* XXX
           * This fixes a try_connections() core (caused by invalid class_ptr
           * pointers) reported by metalrock. That's an ugly fix, but there
           * is currently no better way. The entire config subsystem needs an
           * rewrite ASAP. make_conf_item() shouldn't really add things onto
           * a doubly linked list immediately without any sanity checks!  -Michael
           */
          delete_conf_item(yy_conf);

          yy_aconf = NULL;
	  yy_conf = NULL;
	}

      /*
       * yy_conf is still pointing at the server that is having
       * a connect block built for it. This means, y_aconf->name 
       * points to the actual irc name this server will be known as.
       * Now this new server has a set or even just one hub_mask (or leaf_mask)
       * given in the link list at yy_hconf. Fill in the HUB confs
       * from this link list now.
       */        
      DLINK_FOREACH_SAFE(ptr, next_ptr, hub_conf_list.head)
      {
	struct ConfItem *new_hub_conf;
	struct MatchItem *match_item;

	yy_hconf = ptr->data;

	/* yy_conf == NULL is a fatal error for this connect block! */
	if ((yy_conf != NULL) && (yy_conf->name != NULL))
	{
	  new_hub_conf = make_conf_item(HUB_TYPE);
	  match_item = (struct MatchItem *)map_to_conf(new_hub_conf);
	  DupString(new_hub_conf->name, yy_conf->name);
	  if (yy_hconf->user != NULL)
	    DupString(match_item->user, yy_hconf->user);
	  else
	    DupString(match_item->user, "*");
	  if (yy_hconf->host != NULL)
	    DupString(match_item->host, yy_hconf->host);
	  else
	    DupString(match_item->host, "*");
	}
	dlinkDelete(&yy_hconf->node, &hub_conf_list);
	free_collect_item(yy_hconf);
      }

      /* Ditto for the LEAF confs */

      DLINK_FOREACH_SAFE(ptr, next_ptr, leaf_conf_list.head)
      {
	struct ConfItem *new_leaf_conf;
	struct MatchItem *match_item;

	yy_lconf = ptr->data;

	if ((yy_conf != NULL) && (yy_conf->name != NULL))
	{
	  new_leaf_conf = make_conf_item(LEAF_TYPE);
	  match_item = (struct MatchItem *)map_to_conf(new_leaf_conf);
	  DupString(new_leaf_conf->name, yy_conf->name);
	  if (yy_lconf->user != NULL)
	    DupString(match_item->user, yy_lconf->user);
	  else
	    DupString(match_item->user, "*");
	  if (yy_lconf->host != NULL)
	    DupString(match_item->host, yy_lconf->host);
	  else
	    DupString(match_item->host, "*");
	}
	dlinkDelete(&yy_lconf->node, &leaf_conf_list);
	free_collect_item(yy_lconf);
      }
      MyFree(class_name);
      class_name = NULL;
      yy_conf = NULL;
      yy_aconf = NULL;
  }
}
break;
case 436:
#line 2748 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_conf->name != NULL)
      yyerror("Multiple connect name entry");

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 437:
#line 2760 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_conf->name != NULL)
      yyerror("Multiple connect name entry");

    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 438:
#line 2772 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->host);
    DupString(yy_aconf->host, yylval.string);
  }
}
break;
case 439:
#line 2781 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct addrinfo hints, *res;

    memset(&hints, 0, sizeof(hints));

    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_NUMERICHOST;

    if (irc_getaddrinfo(yylval.string, NULL, &hints, &res))
      ilog(L_ERROR, "Invalid netmask for server vhost(%s)", yylval.string);
    else
    {
      assert(res != NULL);

      memcpy(&yy_aconf->my_ipnum, res->ai_addr, res->ai_addrlen);
      yy_aconf->my_ipnum.ss.ss_family = res->ai_family;
      yy_aconf->my_ipnum.ss_len = res->ai_addrlen;
      irc_freeaddrinfo(res);
    }
  }
}
break;
case 440:
#line 2807 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yyvsp[-1].string[0] == ':')
      yyerror("Server passwords cannot begin with a colon");
    else if (strchr(yyvsp[-1].string, ' ') != NULL)
      yyerror("Server passwords cannot contain spaces");
    else {
      if (yy_aconf->spasswd != NULL)
        memset(yy_aconf->spasswd, 0, strlen(yy_aconf->spasswd));

      MyFree(yy_aconf->spasswd);
      DupString(yy_aconf->spasswd, yylval.string);
    }
  }
}
break;
case 441:
#line 2825 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yyvsp[-1].string[0] == ':')
      yyerror("Server passwords cannot begin with a colon");
    else if (strchr(yyvsp[-1].string, ' ') != NULL)
      yyerror("Server passwords cannot contain spaces");
    else {
      if (yy_aconf->passwd != NULL)
        memset(yy_aconf->passwd, 0, strlen(yy_aconf->passwd));

      MyFree(yy_aconf->passwd);
      DupString(yy_aconf->passwd, yylval.string);
    }
  }
}
break;
case 442:
#line 2843 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->port = yyvsp[-1].number;
}
break;
case 443:
#line 2849 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->aftype = AF_INET;
}
break;
case 444:
#line 2853 "ircd_parser.y"
{
#ifdef IPV6
  if (ypass == 2)
    yy_aconf->aftype = AF_INET6;
#endif
}
break;
case 445:
#line 2861 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->fakename);
    DupString(yy_aconf->fakename, yylval.string);
  }
}
break;
case 446:
#line 2870 "ircd_parser.y"
{
}
break;
case 450:
#line 2874 "ircd_parser.y"
{ not_atom = 1; }
break;
case 452:
#line 2875 "ircd_parser.y"
{ not_atom = 0; }
break;
case 454:
#line 2878 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)ClearConfLazyLink(yy_aconf);
    else SetConfLazyLink(yy_aconf);
  }
}
break;
case 455:
#line 2885 "ircd_parser.y"
{
  if (ypass == 2)
#ifndef HAVE_LIBZ
    yyerror("Ignoring flags = compressed; -- no zlib support");
#else
 {
   if (not_atom)ClearConfCompressed(yy_aconf);
   else SetConfCompressed(yy_aconf);
 }
#endif
}
break;
case 456:
#line 2896 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)ClearConfCryptLink(yy_aconf);
    else SetConfCryptLink(yy_aconf);
  }
}
break;
case 457:
#line 2903 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)ClearConfAllowAutoConn(yy_aconf);
    else SetConfAllowAutoConn(yy_aconf);
  }
}
break;
case 458:
#line 2910 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)ClearConfAwayBurst(yy_aconf);
    else SetConfAwayBurst(yy_aconf);
  }
}
break;
case 459:
#line 2917 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (not_atom)ClearConfTopicBurst(yy_aconf);
    else SetConfTopicBurst(yy_aconf);
  }
}
break;
case 460:
#line 2927 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    BIO *file;

    if (yy_aconf->rsa_public_key != NULL)
    {
      RSA_free(yy_aconf->rsa_public_key);
      yy_aconf->rsa_public_key = NULL;
    }

    if (yy_aconf->rsa_public_key_file != NULL)
    {
      MyFree(yy_aconf->rsa_public_key_file);
      yy_aconf->rsa_public_key_file = NULL;
    }

    DupString(yy_aconf->rsa_public_key_file, yylval.string);

    if ((file = BIO_new_file(yylval.string, "r")) == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- file doesn't exist");
      break;
    }

    yy_aconf->rsa_public_key = (RSA *)PEM_read_bio_RSA_PUBKEY(file, NULL, 0, NULL);

    if (yy_aconf->rsa_public_key == NULL)
    {
      yyerror("Ignoring rsa_public_key_file -- Key invalid; check key syntax.");
      break;
    }

    (void)BIO_set_close(file, BIO_CLOSE);
    BIO_free(file);
  }
#endif /* HAVE_LIBCRYPTO */
}
break;
case 461:
#line 2968 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_ENCRYPTED;
    else
      yy_aconf->flags &= ~CONF_FLAGS_ENCRYPTED;
  }
}
break;
case 462:
#line 2979 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_CRYPTLINK;
    else
      yy_aconf->flags &= ~CONF_FLAGS_CRYPTLINK;
  }
}
break;
case 463:
#line 2990 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
#ifndef HAVE_LIBZ
      yyerror("Ignoring compressed=yes; -- no zlib support");
#else
      yy_aconf->flags |= CONF_FLAGS_COMPRESSED;
#endif
    else
      yy_aconf->flags &= ~CONF_FLAGS_COMPRESSED;
  }
}
break;
case 464:
#line 3005 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      yy_aconf->flags |= CONF_FLAGS_ALLOW_AUTO_CONN;
    else
      yy_aconf->flags &= ~CONF_FLAGS_ALLOW_AUTO_CONN;
  }
}
break;
case 465:
#line 3016 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.number)
      SetConfTopicBurst(yy_aconf);
    else
      ClearConfTopicBurst(yy_aconf);
  }
}
break;
case 466:
#line 3027 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    yy_tmp = (struct CollectItem *)MyMalloc(sizeof(struct CollectItem));
    DupString(yy_tmp->host, yylval.string);
    DupString(yy_tmp->user, "*");
    dlinkAdd(yy_tmp, &yy_tmp->node, &hub_conf_list);
  }
}
break;
case 467:
#line 3040 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp;

    yy_tmp = (struct CollectItem *)MyMalloc(sizeof(struct CollectItem));
    DupString(yy_tmp->host, yylval.string);
    DupString(yy_tmp->user, "*");
    dlinkAdd(yy_tmp, &yy_tmp->node, &leaf_conf_list);
  }
}
break;
case 468:
#line 3053 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(class_name);
    DupString(class_name, yylval.string);
  }
}
break;
case 469:
#line 3062 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    struct EncCapability *ecap;
    const char *cipher_name;
    int found = 0;

    yy_aconf->cipher_preference = NULL;
    cipher_name = yylval.string;

    for (ecap = CipherTable; ecap->name; ecap++)
    {
      if ((irccmp(ecap->name, cipher_name) == 0) &&
          (ecap->cap & CAP_ENC_MASK))
      {
        yy_aconf->cipher_preference = ecap;
        found = 1;
        break;
      }
    }

    if (!found)
      yyerror("Invalid cipher");
  }
#else
  if (ypass == 2)
    yyerror("Ignoring cipher_preference -- no OpenSSL support");
#endif
}
break;
case 470:
#line 3097 "ircd_parser.y"
{
  if (ypass == 2)
  {
    userbuf[0] = hostbuf[0] = reasonbuf[0] = '\0';
    regex_ban = 0;
  }
}
break;
case 471:
#line 3104 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (userbuf[0] && hostbuf[0])
    {
      if (regex_ban)
      {
        pcre *exp_user = NULL;
        pcre *exp_host = NULL;
        const char *errptr = NULL;

        if (!(exp_user = ircd_pcre_compile(userbuf, &errptr)) ||
            !(exp_host = ircd_pcre_compile(hostbuf, &errptr)))
        {
          ilog(L_ERROR, "Failed to add regular expression based K-Line: %s", errptr);
          break;
        }

        yy_conf = make_conf_item(RKLINE_TYPE);
	yy_aconf = map_to_conf(yy_conf);

        yy_aconf->regexuser = exp_user;
        yy_aconf->regexhost = exp_host;

        DupString(yy_aconf->user, userbuf);
        DupString(yy_aconf->host, hostbuf);

        if (reasonbuf[0])
          DupString(yy_aconf->reason, reasonbuf);
        else
          DupString(yy_aconf->reason, "No reason");
      }
      else
      {
        yy_conf = make_conf_item(KLINE_TYPE);
        yy_aconf = map_to_conf(yy_conf);

        DupString(yy_aconf->user, userbuf);
        DupString(yy_aconf->host, hostbuf);

        if (reasonbuf[0])
          DupString(yy_aconf->reason, reasonbuf);
        else
          DupString(yy_aconf->reason, "No reason");
        add_conf_by_address(CONF_KILL, yy_aconf);
      }
    }
    else
      delete_conf_item(yy_conf);

    yy_conf = NULL;
    yy_aconf = NULL;
  }
}
break;
case 472:
#line 3160 "ircd_parser.y"
{
}
break;
case 476:
#line 3165 "ircd_parser.y"
{
  if (ypass == 2)
    regex_ban = 1;
}
break;
case 483:
#line 3174 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct split_nuh_item nuh;

    nuh.nuhmask  = yylval.string;
    nuh.nickptr  = NULL;
    nuh.userptr  = userbuf;
    nuh.hostptr  = hostbuf;

    nuh.nicksize = 0;
    nuh.usersize = sizeof(userbuf);
    nuh.hostsize = sizeof(hostbuf);

    split_nuh(&nuh);
  }
}
break;
case 484:
#line 3193 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(reasonbuf, yylval.string, sizeof(reasonbuf));
}
break;
case 485:
#line 3202 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(DLINE_TYPE);
    yy_aconf = map_to_conf(yy_conf);
    /* default reason */
    DupString(yy_aconf->reason, "No reason");
  }
}
break;
case 486:
#line 3211 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yy_aconf->host && parse_netmask(yy_aconf->host, NULL, NULL) != HM_HOST)
      add_conf_by_address(CONF_DLINE, yy_aconf);
    else
      delete_conf_item(yy_conf);
    yy_conf = NULL;
    yy_aconf = NULL;
  }
}
break;
case 492:
#line 3227 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->host);
    DupString(yy_aconf->host, yylval.string);
  }
}
break;
case 493:
#line 3236 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(yy_aconf->reason);
    DupString(yy_aconf->reason, yylval.string);
  }
}
break;
case 500:
#line 3253 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (yylval.string[0] && parse_netmask(yylval.string, NULL, NULL) != HM_HOST)
    {
      yy_conf = make_conf_item(EXEMPTDLINE_TYPE);
      yy_aconf = map_to_conf(yy_conf);
      DupString(yy_aconf->host, yylval.string);

      add_conf_by_address(CONF_EXEMPTDLINE, yy_aconf);

      yy_conf = NULL;
      yy_aconf = NULL;
    }
  }
}
break;
case 501:
#line 3271 "ircd_parser.y"
{
  if (ypass == 2)
  {
#ifdef HAVE_LIBCRYPTO
    char tmp[SHA_DIGEST_LENGTH];

    yy_conf = make_conf_item(EXEMPTDLINE_TYPE);
    yy_aconf = map_to_conf(yy_conf);
  
    if(base16_decode(tmp, SHA_DIGEST_LENGTH, yylval.string, strlen(yylval.string)) != 0)
    {
      yyerror("Invalid client certificate fingerprint provided. Ignoring");
      break;
    }
 
    yy_aconf->certfp = MyMalloc(SHA_DIGEST_LENGTH);
    yy_aconf->host = MyMalloc(SHA_DIGEST_LENGTH);
    memcpy(yy_aconf->certfp, tmp, SHA_DIGEST_LENGTH);
    memcpy(yy_aconf->host, tmp, SHA_DIGEST_LENGTH);
 
    add_conf_by_address(CONF_EXEMPTDLINE, yy_aconf);

    yy_conf = NULL;
    yy_aconf = NULL;
#endif
 }
}
break;
case 502:
#line 3304 "ircd_parser.y"
{
  if (ypass == 2)
  {
    regex_ban = 0;
    reasonbuf[0] = gecos_name[0] = '\0';
  }
}
break;
case 503:
#line 3311 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (gecos_name[0])
    {
      if (regex_ban)
      {
        pcre *exp_p = NULL;
        const char *errptr = NULL;

        if (!(exp_p = ircd_pcre_compile(gecos_name, &errptr)))
        {
          ilog(L_ERROR, "Failed to add regular expression based X-Line: %s", errptr);
          break;
        }

        yy_conf = make_conf_item(RXLINE_TYPE);
        yy_conf->regexpname = exp_p;
      }
      else
        yy_conf = make_conf_item(XLINE_TYPE);

      yy_match_item = map_to_conf(yy_conf);
      DupString(yy_conf->name, gecos_name);

      if (reasonbuf[0])
        DupString(yy_match_item->reason, reasonbuf);
      else
        DupString(yy_match_item->reason, "No reason");
    }
  }
}
break;
case 504:
#line 3345 "ircd_parser.y"
{
}
break;
case 508:
#line 3350 "ircd_parser.y"
{
  if (ypass == 2)
    regex_ban = 1;
}
break;
case 515:
#line 3359 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(gecos_name, yylval.string, sizeof(gecos_name));
}
break;
case 516:
#line 3365 "ircd_parser.y"
{
  if (ypass == 2)
    strlcpy(reasonbuf, yylval.string, sizeof(reasonbuf));
}
break;
case 584:
#line 3414 "ircd_parser.y"
{
  ConfigFileEntry.gline_min_cidr = yyvsp[-1].number;
}
break;
case 585:
#line 3419 "ircd_parser.y"
{
  ConfigFileEntry.gline_min_cidr6 = yyvsp[-1].number;
}
break;
case 586:
#line 3424 "ircd_parser.y"
{
  ConfigFileEntry.burst_away = yylval.number;
}
break;
case 587:
#line 3429 "ircd_parser.y"
{
  ConfigFileEntry.use_whois_actually = yylval.number;
}
break;
case 588:
#line 3434 "ircd_parser.y"
{
  GlobalSetOptions.rejecttime = yylval.number;
}
break;
case 589:
#line 3439 "ircd_parser.y"
{
  ConfigFileEntry.tkline_expire_notices = yylval.number;
}
break;
case 590:
#line 3444 "ircd_parser.y"
{
  ConfigFileEntry.kill_chase_time_limit = yyvsp[-1].number;
}
break;
case 591:
#line 3449 "ircd_parser.y"
{
  ConfigFileEntry.hide_spoof_ips = yylval.number;
}
break;
case 592:
#line 3454 "ircd_parser.y"
{
  ConfigFileEntry.ignore_bogus_ts = yylval.number;
}
break;
case 593:
#line 3459 "ircd_parser.y"
{
  ConfigFileEntry.disable_remote = yylval.number;
}
break;
case 594:
#line 3464 "ircd_parser.y"
{
  ConfigFileEntry.failed_oper_notice = yylval.number;
}
break;
case 595:
#line 3469 "ircd_parser.y"
{
  ConfigFileEntry.anti_nick_flood = yylval.number;
}
break;
case 596:
#line 3474 "ircd_parser.y"
{
  ConfigFileEntry.max_nick_time = yyvsp[-1].number; 
}
break;
case 597:
#line 3479 "ircd_parser.y"
{
  ConfigFileEntry.max_nick_changes = yyvsp[-1].number;
}
break;
case 598:
#line 3484 "ircd_parser.y"
{
  ConfigFileEntry.max_accept = yyvsp[-1].number;
}
break;
case 599:
#line 3489 "ircd_parser.y"
{
  ConfigFileEntry.anti_spam_exit_message_time = yyvsp[-1].number;
}
break;
case 600:
#line 3494 "ircd_parser.y"
{
  ConfigFileEntry.anti_spam_connect_numeric = yylval.number;
}
break;
case 601:
#line 3499 "ircd_parser.y"
{
  ConfigFileEntry.ts_warn_delta = yyvsp[-1].number;
}
break;
case 602:
#line 3504 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.ts_max_delta = yyvsp[-1].number;
}
break;
case 603:
#line 3510 "ircd_parser.y"
{
  if ((yyvsp[-1].number > 0) && ypass == 1)
  {
    ilog(L_CRIT, "You haven't read your config file properly.");
    ilog(L_CRIT, "There is a line in the example conf that will kill your server if not removed.");
    ilog(L_CRIT, "Consider actually reading/editing the conf file, and removing this line.");
    exit(0);
  }
}
break;
case 604:
#line 3521 "ircd_parser.y"
{
  ConfigFileEntry.kline_with_reason = yylval.number;
}
break;
case 605:
#line 3526 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.kline_reason);
    DupString(ConfigFileEntry.kline_reason, yylval.string);
  }
}
break;
case 606:
#line 3535 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.cloak_key1);
    DupString(ConfigFileEntry.cloak_key1, yylval.string);
  }
}
break;
case 607:
#line 3544 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.cloak_key2);
    DupString(ConfigFileEntry.cloak_key2, yylval.string);
  }
}
break;
case 608:
#line 3553 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.cloak_key3);
    DupString(ConfigFileEntry.cloak_key3, yylval.string);
  }
}
break;
case 609:
#line 3562 "ircd_parser.y"
{
  ConfigFileEntry.cloak_whois_actually = yylval.number;
}
break;
case 610:
#line 3567 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.services_name);
    DupString(ConfigFileEntry.services_name, yylval.string);
  }
}
break;
case 611:
#line 3576 "ircd_parser.y"
{
  ConfigFileEntry.invisible_on_connect = yylval.number;
}
break;
case 612:
#line 3581 "ircd_parser.y"
{
  ConfigFileEntry.warn_no_nline = yylval.number;
}
break;
case 613:
#line 3586 "ircd_parser.y"
{
  ConfigFileEntry.stats_e_disabled = yylval.number;
}
break;
case 614:
#line 3591 "ircd_parser.y"
{
  ConfigFileEntry.stats_o_oper_only = yylval.number;
}
break;
case 615:
#line 3596 "ircd_parser.y"
{
  ConfigFileEntry.stats_P_oper_only = yylval.number;
}
break;
case 616:
#line 3601 "ircd_parser.y"
{
  ConfigFileEntry.hide_killer = yylval.number;
}
break;
case 617:
#line 3606 "ircd_parser.y"
{
  ConfigFileEntry.stats_k_oper_only = 2 * yylval.number;
}
break;
case 618:
#line 3609 "ircd_parser.y"
{
  ConfigFileEntry.stats_k_oper_only = 1;
}
break;
case 619:
#line 3614 "ircd_parser.y"
{
  ConfigFileEntry.stats_i_oper_only = 2 * yylval.number;
}
break;
case 620:
#line 3617 "ircd_parser.y"
{
  ConfigFileEntry.stats_i_oper_only = 1;
}
break;
case 621:
#line 3622 "ircd_parser.y"
{
  ConfigFileEntry.pace_wait = yyvsp[-1].number;
}
break;
case 622:
#line 3627 "ircd_parser.y"
{
  ConfigFileEntry.caller_id_wait = yyvsp[-1].number;
}
break;
case 623:
#line 3632 "ircd_parser.y"
{
  ConfigFileEntry.opers_bypass_callerid = yylval.number;
}
break;
case 624:
#line 3637 "ircd_parser.y"
{
  ConfigFileEntry.pace_wait_simple = yyvsp[-1].number;
}
break;
case 625:
#line 3642 "ircd_parser.y"
{
  ConfigFileEntry.short_motd = yylval.number;
}
break;
case 626:
#line 3647 "ircd_parser.y"
{
  ConfigFileEntry.no_oper_flood = yylval.number;
}
break;
case 627:
#line 3652 "ircd_parser.y"
{
  ConfigFileEntry.true_no_oper_flood = yylval.number;
}
break;
case 628:
#line 3657 "ircd_parser.y"
{
  ConfigFileEntry.oper_pass_resv = yylval.number;
}
break;
case 629:
#line 3662 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if (strlen(yylval.string) > LOCALE_LENGTH-2)
      yylval.string[LOCALE_LENGTH-1] = '\0';

    set_locale(yylval.string);
  }
}
break;
case 630:
#line 3673 "ircd_parser.y"
{
  ConfigFileEntry.idletime = yyvsp[-1].number;
}
break;
case 631:
#line 3678 "ircd_parser.y"
{
  ConfigFileEntry.dots_in_ident = yyvsp[-1].number;
}
break;
case 632:
#line 3683 "ircd_parser.y"
{
  ConfigFileEntry.max_targets = yyvsp[-1].number;
}
break;
case 633:
#line 3688 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.servlink_path);
    DupString(ConfigFileEntry.servlink_path, yylval.string);
  }
}
break;
case 634:
#line 3697 "ircd_parser.y"
{
#ifdef HAVE_LIBCRYPTO
  if (ypass == 2)
  {
    struct EncCapability *ecap;
    const char *cipher_name;
    int found = 0;

    ConfigFileEntry.default_cipher_preference = NULL;
    cipher_name = yylval.string;

    for (ecap = CipherTable; ecap->name; ecap++)
    {
      if ((irccmp(ecap->name, cipher_name) == 0) &&
          (ecap->cap & CAP_ENC_MASK))
      {
        ConfigFileEntry.default_cipher_preference = ecap;
        found = 1;
        break;
      }
    }

    if (!found)
      yyerror("Invalid cipher");
  }
#else
  if (ypass == 2)
    yyerror("Ignoring default_cipher_preference -- no OpenSSL support");
#endif
}
break;
case 635:
#line 3729 "ircd_parser.y"
{
  if (ypass == 2)
  {
    ConfigFileEntry.compression_level = yyvsp[-1].number;
#ifndef HAVE_LIBZ
    yyerror("Ignoring compression_level -- no zlib support");
#else
    if ((ConfigFileEntry.compression_level < 1) ||
        (ConfigFileEntry.compression_level > 9))
    {
      yyerror("Ignoring invalid compression_level, using default");
      ConfigFileEntry.compression_level = 0;
    }
#endif
  }
}
break;
case 636:
#line 3747 "ircd_parser.y"
{
  ConfigFileEntry.use_egd = yylval.number;
}
break;
case 637:
#line 3752 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigFileEntry.egdpool_path);
    DupString(ConfigFileEntry.egdpool_path, yylval.string);
  }
}
break;
case 638:
#line 3761 "ircd_parser.y"
{
  ConfigFileEntry.ping_cookie = yylval.number;
}
break;
case 639:
#line 3766 "ircd_parser.y"
{
  ConfigFileEntry.disable_auth = yylval.number;
}
break;
case 640:
#line 3771 "ircd_parser.y"
{
  ConfigFileEntry.throttle_num = yylval.number;
}
break;
case 641:
#line 3776 "ircd_parser.y"
{
  ConfigFileEntry.throttle_time = yylval.number;
}
break;
case 642:
#line 3781 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes = 0;
}
break;
case 646:
#line 3787 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_BOTS;
}
break;
case 647:
#line 3790 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_CCONN;
}
break;
case 648:
#line 3793 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_NOCTCP;
}
break;
case 649:
#line 3796 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_DEAF;
}
break;
case 650:
#line 3799 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_DEBUG;
}
break;
case 651:
#line 3802 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_FULL;
}
break;
case 652:
#line 3805 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_SKILL;
}
break;
case 653:
#line 3808 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_NCHANGE;
}
break;
case 654:
#line 3811 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_REJ;
}
break;
case 655:
#line 3814 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_UNAUTH;
}
break;
case 656:
#line 3817 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_SPY;
}
break;
case 657:
#line 3820 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_EXTERNAL;
}
break;
case 658:
#line 3823 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_OPERWALL;
}
break;
case 659:
#line 3826 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_SERVNOTICE;
}
break;
case 660:
#line 3829 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_INVISIBLE;
}
break;
case 661:
#line 3832 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_WALLOP;
}
break;
case 662:
#line 3835 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_SOFTCALLERID;
}
break;
case 663:
#line 3838 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_CALLERID;
}
break;
case 664:
#line 3841 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_LOCOPS;
}
break;
case 665:
#line 3844 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_HIDECHANNELS;
}
break;
case 666:
#line 3847 "ircd_parser.y"
{
  ConfigFileEntry.oper_umodes |= UMODE_FARCONNECT;
}
break;
case 667:
#line 3852 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes = 0;
}
break;
case 671:
#line 3858 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_BOTS;
}
break;
case 672:
#line 3861 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_CCONN;
}
break;
case 673:
#line 3864 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_NOCTCP;
}
break;
case 674:
#line 3867 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_DEAF;
}
break;
case 675:
#line 3870 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_DEBUG;
}
break;
case 676:
#line 3873 "ircd_parser.y"
{ 
  ConfigFileEntry.oper_only_umodes |= UMODE_FULL;
}
break;
case 677:
#line 3876 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_SKILL;
}
break;
case 678:
#line 3879 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_NCHANGE;
}
break;
case 679:
#line 3882 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_REJ;
}
break;
case 680:
#line 3885 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_UNAUTH;
}
break;
case 681:
#line 3888 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_SPY;
}
break;
case 682:
#line 3891 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_EXTERNAL;
}
break;
case 683:
#line 3894 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_OPERWALL;
}
break;
case 684:
#line 3897 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_SERVNOTICE;
}
break;
case 685:
#line 3900 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_INVISIBLE;
}
break;
case 686:
#line 3903 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_WALLOP;
}
break;
case 687:
#line 3906 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_SOFTCALLERID;
}
break;
case 688:
#line 3909 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_CALLERID;
}
break;
case 689:
#line 3912 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_LOCOPS;
}
break;
case 690:
#line 3915 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_HIDECHANNELS;
}
break;
case 691:
#line 3918 "ircd_parser.y"
{
  ConfigFileEntry.oper_only_umodes |= UMODE_FARCONNECT;
}
break;
case 692:
#line 3923 "ircd_parser.y"
{
  ConfigFileEntry.min_nonwildcard = yyvsp[-1].number;
}
break;
case 693:
#line 3928 "ircd_parser.y"
{
  ConfigFileEntry.min_nonwildcard_simple = yyvsp[-1].number;
}
break;
case 694:
#line 3933 "ircd_parser.y"
{
  ConfigFileEntry.default_floodcount = yyvsp[-1].number;
}
break;
case 695:
#line 3938 "ircd_parser.y"
{
  ConfigFileEntry.client_flood = yyvsp[-1].number;
}
break;
case 696:
#line 3943 "ircd_parser.y"
{
  ConfigFileEntry.dot_in_ip6_addr = yylval.number;
}
break;
case 697:
#line 3951 "ircd_parser.y"
{
  if (ypass == 2)
  {
    yy_conf = make_conf_item(GDENY_TYPE);
    yy_aconf = map_to_conf(yy_conf);
  }
}
break;
case 698:
#line 3958 "ircd_parser.y"
{
  if (ypass == 2)
  {
    /*
     * since we re-allocate yy_conf/yy_aconf after the end of action=, at the
     * end we will have one extra, so we should free it.
     */
    if (yy_conf->name == NULL || yy_aconf->user == NULL)
    {
      delete_conf_item(yy_conf);
      yy_conf = NULL;
      yy_aconf = NULL;
    }
  }
}
break;
case 708:
#line 3984 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.glines = yylval.number;
}
break;
case 709:
#line 3990 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_time = yyvsp[-1].number;
}
break;
case 710:
#line 3996 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_logging = 0;
}
break;
case 714:
#line 4002 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_logging |= GDENY_REJECT;
}
break;
case 715:
#line 4006 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigFileEntry.gline_logging |= GDENY_BLOCK;
}
break;
case 716:
#line 4012 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct split_nuh_item nuh;

    nuh.nuhmask  = yylval.string;
    nuh.nickptr  = NULL;
    nuh.userptr  = userbuf;
    nuh.hostptr  = hostbuf;

    nuh.nicksize = 0;
    nuh.usersize = sizeof(userbuf);
    nuh.hostsize = sizeof(hostbuf);

    split_nuh(&nuh);

    if (yy_aconf->user == NULL)
    {
      DupString(yy_aconf->user, userbuf);
      DupString(yy_aconf->host, hostbuf);
    }
    else
    {
      struct CollectItem *yy_tmp = MyMalloc(sizeof(struct CollectItem));

      DupString(yy_tmp->user, userbuf);
      DupString(yy_tmp->host, hostbuf);

      dlinkAdd(yy_tmp, &yy_tmp->node, &col_conf_list);
    }
  }
}
break;
case 717:
#line 4046 "ircd_parser.y"
{
  if (ypass == 2)  
  {
    MyFree(yy_conf->name);
    DupString(yy_conf->name, yylval.string);
  }
}
break;
case 718:
#line 4055 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags = 0;
}
break;
case 719:
#line 4059 "ircd_parser.y"
{
  if (ypass == 2)
  {
    struct CollectItem *yy_tmp = NULL;
    dlink_node *ptr, *next_ptr;

    DLINK_FOREACH_SAFE(ptr, next_ptr, col_conf_list.head)
    {
      struct AccessItem *new_aconf;
      struct ConfItem *new_conf;

      yy_tmp = ptr->data;
      new_conf = make_conf_item(GDENY_TYPE);
      new_aconf = map_to_conf(new_conf);

      new_aconf->flags = yy_aconf->flags;

      if (yy_conf->name != NULL)
        DupString(new_conf->name, yy_conf->name);
      else
        DupString(new_conf->name, "*");
      if (yy_aconf->user != NULL)
         DupString(new_aconf->user, yy_tmp->user);
      else   
        DupString(new_aconf->user, "*");
      if (yy_aconf->host != NULL)
        DupString(new_aconf->host, yy_tmp->host);
      else
        DupString(new_aconf->host, "*");

      dlinkDelete(&yy_tmp->node, &col_conf_list);
    }

    /*
     * In case someone has fed us with more than one action= after user/name
     * which would leak memory  -Michael
     */
    if (yy_conf->name == NULL || yy_aconf->user == NULL)
      delete_conf_item(yy_conf);

    yy_conf = make_conf_item(GDENY_TYPE);
    yy_aconf = map_to_conf(yy_conf);
  }
}
break;
case 722:
#line 4106 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags |= GDENY_REJECT;
}
break;
case 723:
#line 4110 "ircd_parser.y"
{
  if (ypass == 2)
    yy_aconf->flags |= GDENY_BLOCK;
}
break;
case 749:
#line 4135 "ircd_parser.y"
{
  ConfigChannel.cycle_on_hostchange = yylval.number;
}
break;
case 750:
#line 4140 "ircd_parser.y"
{
  ConfigChannel.disable_fake_channels = yylval.number;
}
break;
case 751:
#line 4145 "ircd_parser.y"
{
  ConfigChannel.restrict_channels = yylval.number;
}
break;
case 752:
#line 4150 "ircd_parser.y"
{
  ConfigChannel.disable_local_channels = yylval.number;
}
break;
case 753:
#line 4155 "ircd_parser.y"
{
  ConfigChannel.use_except = yylval.number;
}
break;
case 754:
#line 4160 "ircd_parser.y"
{
  ConfigChannel.use_invex = yylval.number;
}
break;
case 755:
#line 4165 "ircd_parser.y"
{
  ConfigChannel.regex_bans = yylval.number;
}
break;
case 756:
#line 4170 "ircd_parser.y"
{
  ConfigChannel.use_knock = yylval.number;
}
break;
case 757:
#line 4175 "ircd_parser.y"
{
  ConfigChannel.use_noctcp = yylval.number;
}
break;
case 758:
#line 4180 "ircd_parser.y"
{
  ConfigChannel.knock_delay = yyvsp[-1].number;
}
break;
case 759:
#line 4185 "ircd_parser.y"
{
  ConfigChannel.knock_delay_channel = yyvsp[-1].number;
}
break;
case 760:
#line 4190 "ircd_parser.y"
{
  ConfigChannel.max_chans_per_user = yyvsp[-1].number;
}
break;
case 761:
#line 4195 "ircd_parser.y"
{
  ConfigChannel.quiet_on_ban = yylval.number;
}
break;
case 762:
#line 4200 "ircd_parser.y"
{
  ConfigChannel.max_bans = yyvsp[-1].number;
}
break;
case 763:
#line 4205 "ircd_parser.y"
{
  ConfigChannel.default_split_user_count = yyvsp[-1].number;
}
break;
case 764:
#line 4210 "ircd_parser.y"
{
  ConfigChannel.default_split_server_count = yyvsp[-1].number;
}
break;
case 765:
#line 4215 "ircd_parser.y"
{
  ConfigChannel.no_create_on_split = yylval.number;
}
break;
case 766:
#line 4220 "ircd_parser.y"
{
  ConfigChannel.no_join_on_split = yylval.number;
}
break;
case 767:
#line 4225 "ircd_parser.y"
{
  ConfigChannel.burst_topicwho = yylval.number;
}
break;
case 768:
#line 4230 "ircd_parser.y"
{
  GlobalSetOptions.joinfloodcount = yylval.number;
}
break;
case 769:
#line 4235 "ircd_parser.y"
{
  GlobalSetOptions.joinfloodtime = yylval.number;
}
break;
case 781:
#line 4254 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.flatten_links = yylval.number;
}
break;
case 782:
#line 4260 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.hide_servers = yylval.number;
}
break;
case 783:
#line 4266 "ircd_parser.y"
{
  if (ypass == 2)
  {
    MyFree(ConfigServerHide.hidden_name);
    DupString(ConfigServerHide.hidden_name, yylval.string);
  }
}
break;
case 784:
#line 4275 "ircd_parser.y"
{
  if (ypass == 2)
  {
    if ((yyvsp[-1].number > 0) && ConfigServerHide.links_disabled == 1)
    {
      eventAddIsh("write_links_file", write_links_file, NULL, yyvsp[-1].number);
      ConfigServerHide.links_disabled = 0;
    }

    ConfigServerHide.links_delay = yyvsp[-1].number;
  }
}
break;
case 785:
#line 4289 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.hidden = yylval.number;
}
break;
case 786:
#line 4295 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.disable_hidden = yylval.number;
}
break;
case 787:
#line 4301 "ircd_parser.y"
{
  if (ypass == 2)
    ConfigServerHide.hide_server_ips = yylval.number;
}
break;
#line 6817 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yysslim && yygrowstack())
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;

yyoverflow:
    yyerror("yacc stack overflow");

yyabort:
    return (1);

yyaccept:
    return (0);
}
